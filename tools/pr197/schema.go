// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package main

import "encoding/json"
import "fmt"
import "reflect"

// A test for KeyGen and/or Decaps
type MLKEMTestGroup struct {
	// ParameterSet corresponds to the JSON schema field "parameterSet".
	ParameterSet MLKEMTestGroupParameterSet `json:"parameterSet" yaml:"parameterSet" mapstructure:"parameterSet"`

	// Source corresponds to the JSON schema field "source".
	Source Source `json:"source" yaml:"source" mapstructure:"source"`

	// Tests corresponds to the JSON schema field "tests".
	Tests []MLKEMTestGroupTestsElem `json:"tests" yaml:"tests" mapstructure:"tests"`

	// A legacy field, test files contain only one type per file
	Type MLKEMTestGroupType `json:"type" yaml:"type" mapstructure:"type"`
}

type MLKEMTestGroupParameterSet string

const MLKEMTestGroupParameterSetMLKEM1024 MLKEMTestGroupParameterSet = "ML-KEM-1024"
const MLKEMTestGroupParameterSetMLKEM512 MLKEMTestGroupParameterSet = "ML-KEM-512"
const MLKEMTestGroupParameterSetMLKEM768 MLKEMTestGroupParameterSet = "ML-KEM-768"

var enumValues_MLKEMTestGroupParameterSet = []interface{}{
	"ML-KEM-512",
	"ML-KEM-768",
	"ML-KEM-1024",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MLKEMTestGroupParameterSet) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MLKEMTestGroupParameterSet {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MLKEMTestGroupParameterSet, v)
	}
	*j = MLKEMTestGroupParameterSet(v)
	return nil
}

type MLKEMTestGroupTestsElem struct {
	// The output shared secret
	K string `json:"K" yaml:"K" mapstructure:"K"`

	// An input ciphertext
	C string `json:"c" yaml:"c" mapstructure:"c"`

	// A brief description of the test case
	Comment *string `json:"comment,omitempty" yaml:"comment,omitempty" mapstructure:"comment,omitempty"`

	// The encapsulation key derived from the seed
	Ek *string `json:"ek,omitempty" yaml:"ek,omitempty" mapstructure:"ek,omitempty"`

	// A list of flags
	Flags []string `json:"flags" yaml:"flags" mapstructure:"flags"`

	// Test result
	Result MLKEMTestGroupTestsElemResult `json:"result" yaml:"result" mapstructure:"result"`

	// The d || z seed
	Seed string `json:"seed" yaml:"seed" mapstructure:"seed"`

	// Identifier of the test case
	TcId int `json:"tcId" yaml:"tcId" mapstructure:"tcId"`
}

type MLKEMTestGroupTestsElemResult string

const MLKEMTestGroupTestsElemResultAcceptable MLKEMTestGroupTestsElemResult = "acceptable"
const MLKEMTestGroupTestsElemResultInvalid MLKEMTestGroupTestsElemResult = "invalid"
const MLKEMTestGroupTestsElemResultValid MLKEMTestGroupTestsElemResult = "valid"

var enumValues_MLKEMTestGroupTestsElemResult = []interface{}{
	"valid",
	"invalid",
	"acceptable",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MLKEMTestGroupTestsElemResult) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MLKEMTestGroupTestsElemResult {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MLKEMTestGroupTestsElemResult, v)
	}
	*j = MLKEMTestGroupTestsElemResult(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MLKEMTestGroupTestsElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["K"]; raw != nil && !ok {
		return fmt.Errorf("field K in MLKEMTestGroupTestsElem: required")
	}
	if _, ok := raw["c"]; raw != nil && !ok {
		return fmt.Errorf("field c in MLKEMTestGroupTestsElem: required")
	}
	if _, ok := raw["flags"]; raw != nil && !ok {
		return fmt.Errorf("field flags in MLKEMTestGroupTestsElem: required")
	}
	if _, ok := raw["result"]; raw != nil && !ok {
		return fmt.Errorf("field result in MLKEMTestGroupTestsElem: required")
	}
	if _, ok := raw["seed"]; raw != nil && !ok {
		return fmt.Errorf("field seed in MLKEMTestGroupTestsElem: required")
	}
	if _, ok := raw["tcId"]; raw != nil && !ok {
		return fmt.Errorf("field tcId in MLKEMTestGroupTestsElem: required")
	}
	type Plain MLKEMTestGroupTestsElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MLKEMTestGroupTestsElem(plain)
	return nil
}

type MLKEMTestGroupType string

const MLKEMTestGroupTypeMLKEMTest MLKEMTestGroupType = "MLKEMTest"

var enumValues_MLKEMTestGroupType = []interface{}{
	"MLKEMTest",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MLKEMTestGroupType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MLKEMTestGroupType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MLKEMTestGroupType, v)
	}
	*j = MLKEMTestGroupType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MLKEMTestGroup) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["parameterSet"]; raw != nil && !ok {
		return fmt.Errorf("field parameterSet in MLKEMTestGroup: required")
	}
	if _, ok := raw["source"]; raw != nil && !ok {
		return fmt.Errorf("field source in MLKEMTestGroup: required")
	}
	if _, ok := raw["tests"]; raw != nil && !ok {
		return fmt.Errorf("field tests in MLKEMTestGroup: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in MLKEMTestGroup: required")
	}
	type Plain MLKEMTestGroup
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MLKEMTestGroup(plain)
	return nil
}

type MlkemTestSchemaJson struct {
	// Algorithm corresponds to the JSON schema field "algorithm".
	Algorithm MlkemTestSchemaJsonAlgorithm `json:"algorithm" yaml:"algorithm" mapstructure:"algorithm"`

	// additional documentation
	Header []string `json:"header,omitempty" yaml:"header,omitempty" mapstructure:"header,omitempty"`

	// Notes corresponds to the JSON schema field "notes".
	Notes map[string]NoteEntry `json:"notes,omitempty" yaml:"notes,omitempty" mapstructure:"notes,omitempty"`

	// the number of test vectors in this test
	NumberOfTests int `json:"numberOfTests" yaml:"numberOfTests" mapstructure:"numberOfTests"`

	// Schema corresponds to the JSON schema field "schema".
	Schema MlkemTestSchemaJsonSchema `json:"schema" yaml:"schema" mapstructure:"schema"`

	// TestGroups corresponds to the JSON schema field "testGroups".
	TestGroups []interface{} `json:"testGroups" yaml:"testGroups" mapstructure:"testGroups"`
}

type MlkemTestSchemaJsonAlgorithm string

const MlkemTestSchemaJsonAlgorithmMLKEM MlkemTestSchemaJsonAlgorithm = "ML-KEM"

var enumValues_MlkemTestSchemaJsonAlgorithm = []interface{}{
	"ML-KEM",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MlkemTestSchemaJsonAlgorithm) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MlkemTestSchemaJsonAlgorithm {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MlkemTestSchemaJsonAlgorithm, v)
	}
	*j = MlkemTestSchemaJsonAlgorithm(v)
	return nil
}

type MlkemTestSchemaJsonSchema string

const MlkemTestSchemaJsonSchemaMlkemTestSchemaJson MlkemTestSchemaJsonSchema = "mlkem_test_schema.json"

var enumValues_MlkemTestSchemaJsonSchema = []interface{}{
	"mlkem_test_schema.json",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MlkemTestSchemaJsonSchema) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MlkemTestSchemaJsonSchema {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MlkemTestSchemaJsonSchema, v)
	}
	*j = MlkemTestSchemaJsonSchema(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MlkemTestSchemaJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["algorithm"]; raw != nil && !ok {
		return fmt.Errorf("field algorithm in MlkemTestSchemaJson: required")
	}
	if _, ok := raw["numberOfTests"]; raw != nil && !ok {
		return fmt.Errorf("field numberOfTests in MlkemTestSchemaJson: required")
	}
	if _, ok := raw["schema"]; raw != nil && !ok {
		return fmt.Errorf("field schema in MlkemTestSchemaJson: required")
	}
	if _, ok := raw["testGroups"]; raw != nil && !ok {
		return fmt.Errorf("field testGroups in MlkemTestSchemaJson: required")
	}
	type Plain MlkemTestSchemaJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MlkemTestSchemaJson(plain)
	return nil
}

type NoteEntry struct {
	// The type of the bug tested for
	BugType string `json:"bugType" yaml:"bugType" mapstructure:"bugType"`

	// A list of potentially related CVEs
	Cves []string `json:"cves,omitempty" yaml:"cves,omitempty" mapstructure:"cves,omitempty"`

	// A description of the flag
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The expected effect of failing the test vector
	Effect *string `json:"effect,omitempty" yaml:"effect,omitempty" mapstructure:"effect,omitempty"`

	// A list of potentially related references
	Links []string `json:"links,omitempty" yaml:"links,omitempty" mapstructure:"links,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NoteEntry) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["bugType"]; raw != nil && !ok {
		return fmt.Errorf("field bugType in NoteEntry: required")
	}
	type Plain NoteEntry
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = NoteEntry(plain)
	return nil
}

type Source struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Version corresponds to the JSON schema field "version".
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Source) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Source: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in Source: required")
	}
	type Plain Source
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if len(plain.Version) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "version", 1)
	}
	*j = Source(plain)
	return nil
}
