# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import AST
import collections
import flag
import hkdf
import hkdf_ktv
import producer
import prand
import test_vector
import util
from typing import Optional

# TODO:
#  - Is an IKM size of 0 allowed?
#  - There is an upper limit on the output size.
#    If longer outputs are allowed then partial collisions are
#    possible.
class HkdfTestVector(test_vector.TestVector):
  """A test vector for HKDF (or any other key derivation function with

     input ikm, salt, info, size
  """
  test_attributes = ["ikm", "salt", "info", "size", "okm"]
  schema = {
      "ikm": {
          "type": AST.HexBytes,
          "desc": "the key (input key material)",
      },
      "salt": {
          "type": AST.HexBytes,
          "desc": "the salt for the key derivation",
      },
      "info": {
          "type": AST.HexBytes,
          "desc": "additional information used in the key derivation",
      },
      "size": {
          "type": int,
          "desc": "the size of the output in bytes",
      },
      "okm": {
          "type": AST.HexBytes,
          "desc": "the generated bytes (output key material)",
      },
  }

  def index(self):
    return len(self.ikm)

class HkdfTest(test_vector.TestType):
  """Test vector of type HkdfTest are intended for the verification of HKDF.

     HKDF differs from other key derivation function because the
     function accepts more parameters. I.e. the input for HKDF is a tuple
     (ikm, salt, info, size).
  """

class HkdfTestGroup(test_vector.TestGroup):
  """A test group for key derivation functions that take 4 arguments

     (ikm, salt, info, size) as input.
  """
  algorithm = "HKDF"
  testtype = HkdfTest
  vectortype = HkdfTestVector
  schema = {
      "keySize": {
          "type": int,
          "desc": "the size of the ikm in bits",
      },
  }

  def __init__(self, key_size: int):
    """key_size is in bytes"""
    super().__init__()
    self.keySize = key_size

  def as_struct(self, sort_by=None):
    if sort_by is None:
      sort_by = "comment"
    group = collections.OrderedDict()
    group["type"] = self.testtype
    group["keySize"] = 8 * self.keySize
    group["tests"] = self.get_all_vectors(sort_by=sort_by)
    return group

class HkdfTestGenerator(test_vector.TestGenerator):
  """A generator for HKDF test vectors."""
  def __init__(self, namespace):
    self.args = namespace
    self.hkdf = hkdf.hkdf_for_hash(namespace.sha)
    self.name = "HKDF-" + namespace.sha
    self.sha = namespace.sha
    self.maxsize = 255 * util.digest_size(self.sha)
    self.test = test_vector.Test(self.name)
    super().__init__()

  def new_testgroup(self, idx):
    return HkdfTestGroup(idx)

  @util.type_check
  def gen_test(self,
               ikm: bytes,
               salt: bytes,
               info: bytes,
               size: int,
               expected: Optional[bytes] = None,
               flags: Optional[list[flag.Flag]] = None,
               comment: str = ""):
    if flags is None:
      flags = []
    else:
      flags = flags[:]
    if size > self.maxsize:
      okm = ""
      flags.append(
          flag.Flag(
              label="SizeTooLarge",
              bug_type=flag.BugType.MISSING_STEP,
              description="The output size of HKDF is limited to 255*size of "
              "the hash digest.",
              effect="Computing outputs with a size larger than the limit "
              "allows to find colliding outputs."))
      result = "invalid"
    else:
      okm = self.hkdf(ikm, salt, info, size)
      result = "valid"
    if expected is not None:
      assert okm == expected
    test = HkdfTestVector()
    if len(salt) == 0:
      flags.append(
          flag.Flag(
              label="EmptySalt",
              bug_type=flag.BugType.FUNCTIONALITY,
              description="An empty salt is a valid input for HKDF. "
              "It is equivalent to a salt with n zero bytes, "
              "where n is the size of the underlying hash function."))
    test.comment = comment
    test.ikm = ikm
    test.salt = salt
    test.info = info
    test.size = size
    test.okm = okm
    test.result = result
    test.flags = self.add_flags(flags)
    self.add_test(test)

  def generate_known_test_vectors(self):
    ktv = flag.Flag(
        label="Ktv",
        bug_type=flag.BugType.FUNCTIONALITY,
        description="Known test vector from RFC 5869")

    for t in hkdf_ktv.get_vectors(self.args.sha):
      h, ikm, salt, info, size, okm, comment = t
      assert h == self.args.sha
      self.gen_test(ikm, salt, info, size, okm, comment=comment)

  def generate_pseudorandom(self,
                            cnt: int,
                            ikm_sizes: list[int],
                            salt_sizes: list[int],
                            info_sizes: list[int],
                            output_sizes: list[int],
                            comment: str = "",
                            seed: bytes = "",
                            flags: Optional[list[flag.Flag]] = None):
    """Generates pseudorandom test vectors.

    Args:
        ikm_sizes: the ikm sizes in bytes
        salt_sizes: the salt sizes in bytes
        info_sizes: the info sizes in bytes
        output_sizes: the output sizes in bytes
        comment: information about the test vector
        prefix: a seed used in the pseudorandom generation
        flags: flags added to the test vectors
    """
    for ikm_size in ikm_sizes:
      for salt_size in salt_sizes:
        for info_size in info_sizes:
          for output_size in output_sizes:
            for i in range(cnt):
              ident = b"%s %d %d %d %d %d" % (seed, ikm_size, salt_size,
                                             info_size, output_size, i)
              ikm = prand.randbytes(ikm_size, b"key:", ident)
              salt = prand.randbytes(salt_size, b"msg:", ident)
              info = prand.randbytes(info_size, b"iv:", ident)
              self.gen_test(ikm=ikm, salt=salt, info=info,
                            size=output_size, comment=comment, flags=flags)

  def generate_collision(self, seed: bytes = b"1231971k2j4h"):
    """Generates some collisions."""
    collision = flag.Flag(
        label="OutputCollision",
        bug_type=flag.BugType.FUNCTIONALITY,
        description="HKDF can generate identical output for distinct inputs. "
        "This happens because the underlying HMAC extends or hashes some "
        "inputs. This test vector contains some HKDF inputs that gives the "
        "same output as some other test vector.",
        effect="HKDF should not be used with variable length user defined "
        "salt.")
    digest_size = util.digest_size(self.sha)
    for ikm_size in [digest_size]:
      for info_size in [20]:
        for output_size in [32]:
          ident = b"%s %d %d %d" % (seed, ikm_size, info_size, output_size)
          ikm = prand.randbytes(ikm_size, b"key:", ident)
          info = prand.randbytes(info_size, b"iv:", ident)
          # Case 1 an empty salt is the same as digest_size
          for salt in [bytes(), bytes(digest_size)]:
            comment = ("output collision for different salts")
            self.gen_test(
                ikm=ikm,
                salt=salt,
                info=info,
                size=output_size,
                comment=comment,
                flags=[collision])

          # Case 2: If the salt is longer than the block size of the hash
          #   then the salt is hashed. (Assuming a block size <= 512 bits.
          salt = prand.randbytes(65, b"salt:", ident)
          hashed_salt = util.hash(self.sha, salt)
          for s in [salt, hashed_salt]:
            comment = ("a salt longer than the block size of the hash is"
                       " equivalent to the hash of the salt")
            self.gen_test(
                ikm=ikm,
                salt=s,
                info=info,
                size=output_size,
                comment=comment,
                flags=[collision])

          # Case 3: Padding. If the salt is shorter than the block size
          # then it is padded with zeros to the right.
          salt0 = prand.randbytes(8, b"padding", ident)
          for padlen in range(0, 64 - len(salt0), 8):
            comment = ("a salt shorter than the block size is padded with"
                       " zeros.")
            self.gen_test(
                ikm=ikm,
                salt=salt0 + bytes(padlen),
                info=info,
                size=output_size,
                comment=comment,
                flags=[collision])

  def generate_all(self):
    self.generate_known_test_vectors()
    # typical
    ikm_sizes = [16, 20, 32]
    self.generate_pseudorandom(
        cnt=1,
        ikm_sizes=ikm_sizes,
        salt_sizes=[0, 16, 30],
        info_sizes=[0, 20],
        output_sizes=[20, 42, 64],
        seed=b"1kl3j1l2j",
        flags=[flag.NORMAL])
    # salt size == block size
    self.generate_pseudorandom(
        cnt=1,
        ikm_sizes=ikm_sizes,
        salt_sizes=[64],
        info_sizes=[0, 20],
        output_sizes=[42],
        seed=b"1kkl214j312lk4",
        flags=[flag.NORMAL])
    # longer output size
    mdsize = util.digest_size(self.args.sha)
    self.generate_pseudorandom(
        cnt=1,
        ikm_sizes=[mdsize],
        salt_sizes=[mdsize],
        info_sizes=[8],
        output_sizes=[mdsize, 2 * mdsize - 8, 4 * mdsize],
        seed=b";kl24;h1ypfaal",
        flags=[flag.NORMAL])
    # maximal output size
    self.generate_pseudorandom(
        cnt=1,
        ikm_sizes=ikm_sizes,
        salt_sizes=[mdsize],
        info_sizes=[8],
        output_sizes=[self.maxsize],
        seed=b"kl234hs98df234",
        comment="maximal output size",
        flags = [flag.Flag(
          label="MaximalOutputSize",
          bug_type=flag.BugType.EDGE_CASE,
          description="The test vector contains an output with "
          "maximal output size.")])
    # invalid size
    self.generate_pseudorandom(
        cnt=1,
        ikm_sizes=ikm_sizes,
        salt_sizes=[mdsize],
        info_sizes=[8],
        output_sizes=[self.maxsize + 1],
        seed=b"kl234hs98df234",
        comment="invalid output size")
    # empty salt, long info and output size
    self.generate_pseudorandom(
        cnt=1,
        ikm_sizes=ikm_sizes,
        salt_sizes=[0],
        info_sizes=[65],
        output_sizes=[80],
        seed=b"kj234l234sfe",
        comment="empty salt", flags=[flag.NORMAL])

    # Collisions
    self.generate_collision()


class HkdfProducer(producer.Producer):

  def parser(self):
    res = self.default_parser()
    res.add_argument("--sha", type=str, choices=hkdf.SUPPORTED_HASHES)
    return res

  def generate_test_vectors(self, namespace):
    tv = HkdfTestGenerator(namespace)
    tv.generate_all()
    return tv.test


# DEPRECATED: Use Producer.produce() instead
def main(namespace):
  HkdfProducer().produce(namespace)


if __name__ == "__main__":
  HkdfProducer().produce_with_args()
