# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import asn
import collections
import ec
import gf
import group
import oid
import util
from typing import Optional, Any

Point = tuple[Any, Any]

# TODO: deprecate
EcGroup = group.EcGroup


class EcBinary:
  """A binary elliptic curve defined by y^2 + xy = x^3 + ax^2 + b.
  """

  def __init__(self,
               field: gf.GF,
               a: gf.Element,
               b: gf.Element,
               verify: bool = False):
    if a.field != field:
      raise ValueError("a not an element of the field")
    if b.field != field:
      raise ValueError("b not an element of the field")
    self.a = a
    self.b = b
    self.field = field
    self.verify = verify

  @util.type_check
  def is_on_curve(self, x: gf.Element, y: gf.Element) -> bool:
    if x.field != self.field:
      raise ValueError("x is not an element of the field")
    if y.field != self.field:
      raise ValueError("y is not an element of the field")
    return y * (y + x) == (x + self.a) * x * x + self.b

  def get_ys(self, x: gf.Element) -> list[gf.Element]:
    c = (x + self.a) * x * x + self.b
    return gf.solve_quadratic(self.field(1), x, c)

  @util.type_check
  def get_y(self, x: gf.Element) -> Optional[gf.Element]:
    ys = self.get_ys(x)
    if ys:
      return ys[0]

  def point_from_x(self, x):
    """Returns a point with x-coordinate x or None if no such point exists.

    Args:
      x: the x-coordinate

    Returns:
      a point or None
    """
    if isinstance(x, int):
      x = self.field(x)
    y = self.get_y(x)
    if y is not None:
      return self.point(x, y)

  def zero(self):
    return ec.EcInfPoint(self)

  def point(self, x: gf.Element, y: gf.Element, verify: bool = True):
    return EcBinaryPoint(self, x, y, verify)

  # def twist(self):
  #  """Returns a quadratic twist curve"""
  #  assert self.mod % 4 == 3
  #  return EcMod(self.a, -self.b % self.mod, self.mod)


class EcBinaryPoint(group.Point):

  def __init__(self, curve, x, y, verify: bool = False):
    if verify or curve.verify:
      if not curve.is_on_curve(x, y):
        raise ValueError("Point is not on curve")
    self.curve = curve
    self.x = x
    self.y = y

  def __neg__(self):
    return EcBinaryPoint(self.curve, self.x, self.y + self.x)

  def __eq__(self, p):
    return (isinstance(p, EcBinaryPoint) and self.curve == p.curve and
            self.x == p.x and self.y == p.y)

  def __repr__(self):
    return "(%s, %s)" % (repr(self.x), repr(self.y))

  def __bool__(self):
    return True

  def zero(self):
    return self.curve.zero()

  def affine(self):
    return (self.x, self.y)

  def affine_x(self):
    return self.x

  def affine_y(self):
    return self.y

  def __add__(self, point):
    if isinstance(point, EcBinaryPoint) and self.curve == point.curve:
      if self.x == point.x:
        if self.x + self.y == point.y:
          return ec.EcInfPoint(self.curve)
        else:
          assert self.y == point.y
          l = self.y / self.x + self.x
          x3 = l * l + l + self.curve.a
          y3 = self.x * self.x + l * x3 + x3
          return EcBinaryPoint(self.curve, x3, y3)
      else:
        l = (self.y + point.y) / (self.x + point.x)
        x3 = l * l + l + self.x + point.x + self.curve.a
        y3 = l * (self.x + x3) + x3 + self.y
        return EcBinaryPoint(self.curve, x3, y3)
    else:
      return NotImplemented


  # def twist(self):
  #  """Returns a quadratic twist curve"""
  #  assert self.mod % 4 == 3
  #  return EcMod(self.a, -self.b % self.mod, self.mod)


class EcBinaryGroup(EcGroup):
  """Defines a cyclic group over an elliptic curve defined over a binary field."""

  def __init__(self,
               field: gf.GF,
               n: int,
               a: int,
               b: int,
               gx: int,
               gy: int,
               h: int,
               verify: bool = False):
    """Constructs a new cyclic group of points over an elliptic curve.

    Args:
        field: the underlying field
        n: the order of the group generated by g
        a: the coefficient a of the curve equation
        b: the coefficient b of the curve equation
        gx: the x-coordinate of the generator
        gy: the y-coordinate of the generator
        h: the co-coefficient (i.e. n*h is the number of points on the curve)
        verify: verifies each point
    """
    self.name = None
    self.oid = None
    self.field = field
    self.n = n
    self.a = a
    self.b = b
    self.g = (gx, gy)
    self.h = h
    self.encoding_length = (self.n.bit_length() + 7) // 8
    self.curve = EcBinary(field, field(a), field(b), verify)

  def field_size(self):
    """Return the number of elements of the underlying field."""
    return 2**self.field.degree()

  def params(self):
    return [
        self.name, self.field.poly, self.n, self.a, self.b, self.g, self.h, self.oid
    ]

  def encode_field_element(self, x: gf.Element) -> bytes:
    """Defined in Section 2.3.5 of sec1-v2.pdf"""
    size = (self.field.degree() + 7) // 8
    return int(x).to_bytes(size, "big")

  def encode_uncompressed(self, pt: Point) -> bytes:
    x, y = pt
    res = bytes([4])
    res += self.encode_field_element(x)
    res += self.encode_field_element(y)
    return res

  def encode_compressed(self, pt: Point) -> bytes:
    """Converts a point into its compressed representation.
    
    Defined in SEC 1 v.1.9, Section 2.3.3

    Args:
      pt: affine coordinates.
    Returns:
      the compressed point
    """
    # TODO: point at infinity is encoded as bytes([0])
    x, y = pt
    z = y / x
    res = bytes([2 + int(z) % 2])
    res += self.encode_field_element(x)
    return res

  def __eq__(self, other):
    if not isinstance(other, EcBinaryGroup):
      return False
    return self.params() == other.params()

  def __ne__(self, other):
    return not self == other

  def verify_name(self):
    """Returns true if this is a known named group"""
    return False

  def get_oid_hex(self) -> Optional[str]:
    oid = self.get_oid()
    if oid:
      return oid.hex()

  def get_oid(self) -> Optional[oid.Oid]:
    """Returns the OID of the curve.

    This method verifies that the curve parameters are correct and represent
    the curve with the given OID. I.e., when the test vector generation modifies
    any of the parameters of the curve then the check fails and the result of
    this method is None.

    Returns:
      the OID of the curve or None if
      no OID is known or the curve parameters have been modified.
    """
    if self.verify_name():
      return self.oid
    else:
      return None

  def get_point(self, x, y):
    if isinstance(x, int):
      x = self.field(x)
    if isinstance(y, int):
      y = self.field(y)
    return self.curve.point(x, y)

  def point_from_x(self, x):
    return self.curve.point_from_x(x)

  def get_y(self, x):
    if isinstance(x, int):
      x = self.field(x)
    return self.curve.get_y(x)

  def generator(self):
    return self.get_point(self.g[0], self.g[1])

  def zero(self):
    return self.curve.zero()

  def public(self, priv: int):
    Y = priv * self.generator()
    return EcPublicKey(self, Y.affine())

  def is_on_curve(self, x: int, y: int):
    return self.curve.is_on_curve(self.field(x), self.field(y))

  def asn_struct(self, use_name: bool = True):
    """specifiedCurve: apparently defined in X9.62"""
    # Also: https://www.secg.org/sec1-v2.pdf p.102ff
    return NotImplemented

    version = 1
    fp = asn.Oid("2a8648ce3d0101")
    field = [fp, self.p]
    size = (self.p.bit_length() + 7) // 8
    a = asn.OctetStringFromInt(self.a, size)
    b = asn.OctetStringFromInt(self.b, size)
    curve = [a, b]
    g_octets = self.encode_uncompressed(self.g)
    g = asn.OctetString(g_octets)
    ecparams = [version, field, curve, g, self.n, self.h]
    return ecparams

  def as_struct(self, use_name:bool = True):
    res = collections.OrderedDict()
    res["type"] = "BinaryCurve"
    res["poly"] = AST.BigInt(self.field.poly)
    res["a"] = AST.BigInt(self.a)
    res["b"] = AST.BigInt(self.b)
    res["gx"] = AST.BigInt(self.g[0])
    res["gy"] = AST.BigInt(self.g[1])
    res["h"] = self.h
    res["n"] = AST.BigInt(self.n)
    return res

  def jwk(self):
    """Returns the jwk name of the curve or None if no name is registered."""
    return self.jwk_name


class EcNamedBinaryGroup(EcBinaryGroup):
  """A named EcBinaryGroup"""

  type_info = {"type": str, "desc": "the name of the EC group"}

  def __init__(self,
               name: str,
               field: gf.GF,
               n: int,
               a: int,
               b: int,
               gx: int,
               gy: int,
               h: int = 1,
               curve_oid: oid.Oid = None,
               jwk_name: Optional[str] = None,
               ansi_name: Optional[str] = None,
               ref: Optional[str] = None,
               low_order_points: Optional[list[tuple[int, int]]] = None):
    """Constructs a group over a binary elliptic curve.

    The equation of the curve is y(x+x) == x^3 + a*x^2 + b.

    Args:
      name: the name of the group (e.g. secp256r1)
      field: a binary field
      n: the order of the group
      a: the coefficient a of the curve as integer.
      b: the coefficient b of the curve as integer.
      gx: the x-coordinate of the generator
      gy: the y-coordinate of the generator
      h: the cofactor
      oid: the Object identifier
      jwk_name: the jwk name if the curve is defined
      ansi_name: the name if ANSI defines an alternative name for the curve
      ref: a reference for the definition of the curve
      low_order_points: non-zero points whose order divides the cofactor
    """
    super().__init__(field, n, a, b, gx, gy, h)
    self.name = name
    if curve_oid.description is None:
      curve_oid.description = name
    self.oid = curve_oid
    self.jwk_name = jwk_name
    self.ansi_name = ansi_name
    if ref is None and curve_oid is not None:
      ref = curve_oid.reference
    self.ref = ref
    self._low_order_points = low_order_points

  def as_unnamed_group(self) -> EcBinaryGroup:
    """Returns this group as unnamed group.

       The EC operations are still the same, but the encodings
       are different.
    """
    return EcUnnamedBinaryGroup(self.field, self.n, self.a, self.b, self.g,
                                self.h)

  def verify_name(self):
    """returns true if this.name and this.params() match"""
    return self == named_curve(self.name)

  def asn_struct(self, use_name:bool=True):
    oid = self.get_oid()
    if oid and use_name:
      return asn.Oid(oid)
    else:
      return self.as_unnamed_group().asn_struct(use_name=False)

  def low_order_points(self):
    if self._low_order_points:
      for x, y in self._low_order_points:
        pt = self.curve.point(self.field(x), self.field(y))
        yield pt

  def as_struct(self, use_name=True):
    if use_name and self.verify_name():
      return self.name
    else:
      self.as_unnamed_group().as_struct(False)


def oid_ec(n: int, name: str) -> oid.Oid:
  """returns the OID for {ellipticCurve n}"""
  return oid.Oid([1, 3, 132, 0, n], name,
                 "https://www.secg.org/sec2-v2.pdf")

# from https://www.secg.org/sec2-v2.pdf
sect163k1 = EcNamedBinaryGroup(
    name="sect163k1",
    curve_oid=oid_ec(1, "sect163k1"),
    field=gf.F163,
    a=1,
    b=1,
    gx=0x02FE13C0537BBC11ACAA07D793DE4E6D5E5C94EEE8,
    gy=0x0289070FB05D38FF58321F2E800536D538CCDAA3D9,
    n=0x04000000000000000000020108A2E0CC0D99F8A5EF,
    h=2,
    low_order_points=[(0x0, 0x1)])

sect163r1 = EcNamedBinaryGroup(
    name="sect163r1",
    curve_oid=oid_ec(2, "sect163r1"),
    field=gf.F163,
    a=0x07B6882CAAEFA84F9554FF8428BD88E246D2782AE2,
    b=0x0713612DCDDCB40AAB946BDA29CA91F73AF958AFD9,
    gx=0x0369979697AB43897789566789567F787A7876A654,
    gy=0x00435EDB42EFAFB2989D51FEFCE3C80988F41FF883,
    n=0x03FFFFFFFFFFFFFFFFFFFF48AAB689C29CA710279B,
    h=2,
    low_order_points=[(0x0, 0x9917a2556e1856bc7ea9a472cd01bfb889b95835)])

sect163r2 = EcNamedBinaryGroup(
    name="sect163r2",
    curve_oid=oid_ec(15, "sect163r2"),
    field=gf.F163,
    a=1,
    b=0x020A601907B8C953CA1481EB10512F78744A3205FD,
    gx=0x03F0EBA16286A2D57EA0991168D4994637E8343E36,
    gy=0x00D51FBC6C71A0094FA2CDD545B11C5C0C797324F1,
    n=0x040000000000000000000292FE77E70C12A4234C33,
    h=2,
    low_order_points=[(0x0, 0x2c25b85badf8927593d21c366da89c03969f34da5)])

sect233k1 = EcNamedBinaryGroup(
    name="sect233k1",
    curve_oid=oid_ec(26, "sect233k1"),
    field=gf.F233,
    a=0,
    b=1,
    gx=0x017232BA853A7E731AF129F22FF4149563A419C26BF50A4C9D6EEFAD6126,
    gy=0x01DB537DECE819B7F70F555A67C427A8CD9BF18AEB9B56E0C11056FAE6A3,
    n=0x8000000000000000000000000000069D5BB915BCD46EFB1AD5F173ABDF,
    h=4,
    low_order_points=[(0x0, 0x1), (0x1, 0x1), (0x1, 0x0)])

sect233r1 = EcNamedBinaryGroup(
    name="sect233r1",
    curve_oid=oid_ec(27, "sect233r1"),
    field=gf.F233,
    a=1,
    b=0x0066647EDE6C332C7F8C0923BB58213B333B20E9CE4281FE115F7D8F90AD,
    gx=0x00FAC9DFCBAC8313BB2139F1BB755FEF65BC391F8B36F8F8EB7371FD558B,
    gy=0x01006A08A41903350678E58528BEBF8A0BEFF867A7CA36716F7E01F81052,
    n=0x01000000000000000000000000000013E974E72F8A6922031D2603CFE0D7,
    h=2,
    low_order_points=[
        (0x0, 0x187f85627b97874e747ee31e06d71caaeea52f21253e5f946d061da9138)
    ])

sect239k1 = EcNamedBinaryGroup(
    name="sect239k1",
    curve_oid=oid_ec(3, "sect239k1"),
    field=gf.F239alt,
    a=0,
    b=1,
    gx=0x29A0B6A887A983E9730988A68727A8B2D126C44CC2CC7B2A6555193035DC,
    gy=0x76310804F12E549BDB011C103089E73510ACB275FC312A5DC6B76553F0CA,
    n=0x2000000000000000000000000000005A79FEC67CB6E91F1C1DA800E478A5,
    h=4,
    low_order_points=[(0x0, 0x1), (0x1, 0x1), (0x1, 0x0)])

sect283k1 = EcNamedBinaryGroup(
    name="sect283k1",
    curve_oid=oid_ec(16, "sect283k1"),
    field=gf.F283,
    a=0,
    b=1,
    gx=0x0503213F78CA44883F1A3B8162F188E553CD265F23C1567A16876913B0C2AC2458492836,
    gy=0x01CCDA380F1C9E318D90F95D07E5426FE87E45C0E8184698E45962364E34116177DD2259,
    n=0x01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE9AE2ED07577265DFF7F94451E061E163C61,
    h=4,
    low_order_points=[(0x0, 0x1), (0x1, 0x1), (0x1, 0x0)])

sect283r1 = EcNamedBinaryGroup(
    name="sect283r1",
    curve_oid=oid_ec(17, "sect283r1"),
    field=gf.F283,
    a=1,
    b=0x027B680AC8B8596DA5A4AF8A19A0303FCA97FD7645309FA2A581485AF6263E313B79A2F5,
    gx=0x05F939258DB7DD90E1934F8C70B0DFEC2EED25B8557EAC9C80E2E198F8CDBECD86B12053,
    gy=0x03676854FE24141CB98FE6D4B20D02B4516FF702350EDDB0826779C813F0DF45BE8112F4,
    n=0x03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEF90399660FC938A90165B042A7CEFADB307,
    h=2,
    low_order_points=[(
        0x0,
        0x72bcc9c5792b1ebe81983089fb6f835a2fd220a304424ca17c082ae17442aede9b9b3f6
    )])

sect409k1 = EcNamedBinaryGroup(
    name="sect409k1",
    curve_oid=oid_ec(36, "sect409k1"),
    field=gf.F409,
    a=0,
    b=1,
    gx=int(
        "60F05F658F49C1AD3AB1890F7184210EFD0987E307C84C27ACCFB8F9F67C"
        "C2C460189EB5AAAA62EE222EB1B35540CFE9023746", 16),
    gy=int(
        "1E369050B7C4E42ACBA1DACBF04299C3460782F918EA427E6325165E9EA1"
        "0E3DA5F6C42E9C55215AA9CA27A5863EC48D8E0286B", 16),
    n=int(
        "7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE5F83B2D4"
        "EA20400EC4557D5ED3E3E7CA5B4B5C83B8E01E5FCF", 16),
    h=4,
    low_order_points=[(0x0, 0x1), (0x1, 0x1), (0x1, 0x0)])

sect409r1 = EcNamedBinaryGroup(
    name="sect409r1",
    curve_oid=oid_ec(37, "sect409r1"),
    field=gf.F409,
    a=1,
    b=int(
        "21A5C2C8EE9FEB5C4B9A753B7B476B7FD6422EF1F3DD674761FA99D6AC27"
        "C8A9A197B272822F6CD57A55AA4F50AE317B13545F", 16),
    gx=int(
        "15D4860D088DDB3496B0C6064756260441CDE4AF1771D4DB01FFE5B34E59"
        "703DC255A868A1180515603AEAB60794E54BB7996A7", 16),
    gy=int(
        "61B1CFAB6BE5F32BBFA78324ED106A7636B9C5A7BD198D0158AA4F5488D0"
        "8F38514F1FDF4B4F40D2181B3681C364BA0273C706", 16),
    n=int(
        "10000000000000000000000000000000000000000000000000001E2AAD6A"
        "612F33307BE5FA47C3C9E052F838164CD37D9A21173", 16),
    h=2,
    low_order_points=[
        (0x0,
         int(
             "9935f7e4768ee2ef22f9b4a29f53cb5d93ab2ed0ad7ce57c1b2649fde895950c"
             "f6576773326c528a48e27b872accf0bc25d5ef", 16))
    ])

sect571k1 = EcNamedBinaryGroup(
    name="sect571k1",
    curve_oid=oid_ec(38, "sect571k1"),
    field=gf.F571,
    a=0,
    b=1,
    gx=int(
        "26EB7A859923FBC82189631F8103FE4AC9CA2970012D5D46024804801841"
        "CA44370958493B205E647DA304DB4CEB08CBBD1BA39494776FB988B47174"
        "DCA88C7E2945283A01C8972", 16),
    gy=int(
        "349DC807F4FBF374F4AEADE3BCA95314DD58CEC9F307A54FFC61EFC006D8"
        "A2C9D4979C0AC44AEA74FBEBBB9F772AEDCB620B01A7BA7AF1B320430C85"
        "91984F601CD4C143EF1C7A3", 16),
    n=int(
        "200000000000000000000000000000000000000000000000000000000000"
        "00000000000131850E1F19A63E4B391A8DB917F4138B630D84BE5D639381"
        "E91DEB45CFE778F637C1001", 16),
    h=4,
    low_order_points=[(0x0, 0x1), (0x1, 0x1), (0x1, 0x0)])

sect571r1 = EcNamedBinaryGroup(
    name="sect571r1",
    curve_oid=oid_ec(39, "sect571r1"),
    field=gf.F571,
    a=1,
    b=int(
        "2F40E7E2221F295DE297117B7F3D62F5C6A97FFCB8CEFF1CD6BA8CE4A9A1"
        "8AD84FFABBD8EFA59332BE7AD6756A66E294AFD185A78FF12AA520E4DE73"
        "9BACA0C7FFEFF7F2955727A", 16),
    gx=int(
        "0303001D34B856296C16C0D40D3CD7750A93D1D2955FA80AA5F40FC8DB7B"
        "2ABDBDE53950F4C0D293CDD711A35B67FB1499AE60038614F1394ABFA3B4"
        "C850D927E1E7769C8EEC2D19", 16),
    gy=int(
        "37BF27342DA639B6DCCFFFEB73D69D78C6C27A6009CBBCA1980F8533921E"
        "8A684423E43BAB08A576291AF8F461BB2A8B3531D2F0485C19B16E2F1516"
        "E23DD3C1A4827AF1B8AC15B", 16),
    n=int(
        "3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
        "FFFFFFFFFFFE661CE18FF55987308059B186823851EC7DD9CA1161DE93D5"
        "174D66E8382E9BB2FE84E47", 16),
    h=2,
    low_order_points=[
        (0x0,
         int(
             "732d556640c20b5dd739a058dffd58268d41c59135429eb041d7aa1255902e63"
             "62c4800a874ab0b60536b58460cd20c06f0340e3594a7f771bedfc10ce39b646"
             "99b08443b761c43", 16))
    ])

# Probably defined first in X9.62.
# OIDs are from RFC 3279
c2tnb191v1 = EcNamedBinaryGroup(
    name="c2tnb191v1",
    field=gf.F191,
    curve_oid=oid.fromstr("1.2.840.10045.3.0.5"),
    a=0x2866537b676752636a68f56554e12640276b649ef7526267,
    b=0x2e45ef571f00786f67b0081b9495a3d95462f5de0aa185ec,
    gx=0x36b3daf8a23206f9c4f299d7b21a9c369137f2c84ae1aa0d,
    gy=0x765be73433b3f95e332932e70ea245ca2418ea0ef98018fb,
    n=0x40000000000000000000000004a20e90c39067c893bbb9a5,
    h=0x2)

c2tnb191v2 = EcNamedBinaryGroup(
    name="c2tnb191v2",
    field=gf.F191,
    curve_oid=oid.fromstr("1.2.840.10045.3.0.6"),
    a=0x401028774d7777c7b7666d1366ea432071274f89ff01e718,
    b=0x0620048d28bcbd03b6249c99182b7c8cd19700c362c46a01,
    gx=0x3809b2b7cc1b28cc5a87926aad83fd28789e81e2c9e3bf10,
    gy=0x17434386626d14f3dbf01760d9213a3e1cf37aec437d668a,
    n=0x20000000000000000000000050508cb89f652824e06b8173,
    h=4)

c2tnb191v3 = EcNamedBinaryGroup(
    name="c2tnb191v3",
    field=gf.F191,
    curve_oid=oid.fromstr("1.2.840.10045.3.0.7"),
    a=0x6c01074756099122221056911c77d77e77a777e7e7e77fcb,
    b=0x71fe1af926cf847989efef8db459f66394d90f32ad3f15e8,
    gx=0x375d4ce24fde434489de8746e71786015009e66e38a926dd,
    gy=0x545a39176196575d985999366e6ad34ce0a77cd7127b06be,
    n=0x155555555555555555555555610c0b196812bfb6288a3ea3,
    h=6)

c2tnb239v1 = EcNamedBinaryGroup(
    name="c2tnb239v1",
    field=gf.F239,
    curve_oid=oid.fromstr("1.2.840.10045.3.0.11"),
    a=0x32010857077c5431123a46b808906756f543423e8d27877578125778ac76,
    b=0x790408f2eedaf392b012edefb3392f30f4327c0ca3f31fc383c422aa8c16,
    gx=0x57927098fa932e7c0a96d3fd5b706ef7e5f5c156e16b7e7c86038552e91d,
    gy=0x61d8ee5077c33fecf6f1a16b268de469c3c7744ea9a971649fc7a9616305,
    n=0x2000000000000000000000000000000f4d42ffe1492a4993f1cad666e447,
    h=4)

c2tnb239v2 = EcNamedBinaryGroup(
    name="c2tnb239v2",
    field=gf.F239,
    curve_oid=oid.fromstr("1.2.840.10045.3.0.12"),
    a=0x4230017757a767fae42398569b746325d45313af0766266479b75654e65f,
    b=0x5037ea654196cff0cd82b2c14a2fcf2e3ff8775285b545722f03eacdb74b,
    gx=0x28f9d04e900069c8dc47a08534fe76d2b900b7d7ef31f5709f200c4ca205,
    gy=0x5667334c45aff3b5a03bad9dd75e2c71a99362567d5453f7fa6e227ec833,
    n=0x1555555555555555555555555555553c6f2885259c31e3fcdf154624522d,
    h=6)

c2tnb239v3 = EcNamedBinaryGroup(
    name="c2tnb239v3",
    field=gf.F239,
    curve_oid=oid.fromstr("1.2.840.10045.3.0.13"),
    a=0x01238774666a67766d6676f778e676b66999176666e687666d8766c66a9f,
    b=0x6a941977ba9f6a435199acfc51067ed587f519c5ecb541b8e44111de1d40,
    gx=0x70f6e9d04d289c4e89913ce3530bfde903977d42b146d539bf1bde4e9c92,
    gy=0x2e5a0eaf6e5e1305b9004dce5c0ed7fe59a35608f33837c816d80b79f461,
    n=0x0cccccccccccccccccccccccccccccac4912d2d9df903ef9888b8a0e4cff,
    h=10)

c2tnb359v1 = EcNamedBinaryGroup(
    name="c2tnb359v1",
    field=gf.F359,
    curve_oid=oid.fromstr("1.2.840.10045.3.0.18"),
    a=0x5667676a654b20754f356ea92017d946567c46675556f19556a04616b567d223a5e05656fb549016a96656a557,
    b=0x2472e2d0197c49363f1fe7f5b6db075d52b6947d135d8ca445805d39bc345626089687742b6329e70680231988,
    gx=0x3c258ef3047767e7ede0f1fdaa79daee3841366a132e163aced4ed2401df9c6bdcde98e8e707c07a2239b1b097,
    gy=0x53d7e08529547048121e9c95f3791dd804963948f34fae7bf44ea82365dc7868fe57e4ae2de211305a407104bd,
    n=0x01af286bca1af286bca1af286bca1af286bca1af286bc9fb8f6b85c556892c20a7eb964fe7719e74f490758d3b,
    h=0x4c)

c2tnb431r1 = EcNamedBinaryGroup(
    name="c2tnb431r1",
    field=gf.F431,
    curve_oid=oid.fromstr("1.2.840.10045.3.0.20"),
    a=0x1a827ef00dd6fc0e234caf046c6a5d8a85395b236cc4ad2cf32a0cadbdc9ddf620b0eb9906d0957f6c6feacd615468df104de296cd8f,
    b=0x10d9b4a3d9047d8b154359abfb1b7f5485b04ceb868237ddc9deda982a679a5a919b626d4e50a8dd731b107a9962381fb5d807bf2618,
    gx=0x120fc05d3c67a99de161d2f4092622feca701be4f50f4758714e8a87bbf2a658ef8c21e7c5efe965361f6c2999c0c247b0dbd70ce6b7,
    gy=0x20d0af8903a96f8d5fa2c255745d3c451b302c9346d9b7e485e7bce41f6b591f3e8f6addcbb0bc4c2f947a7de1a89b625d6a598b3760,
    n=0x0340340340340340340340340340340340340340340340340340340323c313fab50589703b5ec68d3587fec60d161cc149c1ad4a91,
    h=0x2760)

binary_curves = [
    sect163k1, sect163r1, sect163r2, sect233k1, sect233r1, sect239k1, sect283k1,
    sect283r1, sect409k1, sect409r1, sect571k1, sect571r1, c2tnb191v1,
    c2tnb191v2, c2tnb191v3, c2tnb239v1, c2tnb239v2, c2tnb239v3, c2tnb359v1,
    c2tnb431r1
]

# TODO: This is a copy of ec_groups.named_curve to avoid
#   circular imports.
def named_curve(name: str):
  name_lower = name.lower()
  for c in binary_curves:
    for n in (c.name, c.jwk_name, c.ansi_name):
      if n and n.lower() == name_lower:
        return c
  raise Exception(name + " is not a know elliptic curve")

def groups():
  for n, g in globals().items():
    if isinstance(g, EcNamedBinaryGroup):
      yield g
