# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import asn
import AST
import base64
import collections
import pem_util
import prand
import pseudoprimes
import util
from typing import Optional, Any


class DsaKey:

  def __init__(self, md: str, p: int, q: int, g: int):
    """Constructs a new DSA key.

    DsaKey is the base class for DsaPublicKey and DsaPrivateKey.
    The class itself should not be instantiated.

    Args:
      md: the hash function for hashing the key (e.g. "SHA-256")
      p: the size of the prime field
      q: the size of the multiplicative subgroup generated by g
      g: a generator of the muliplicative subgroup
    """
    self.md = md
    self.p = p
    self.q = q
    self.g = g
    self.qbits = q.bit_length()

  def check_params(self):
    """Some simple self checks."""
    assert pow(2, self.p, self.p) == 2
    assert pow(2, self.q, self.q) == 2
    assert self.p % self.q == 1
    assert 1 < self.g < self.p
    assert pow(self.g, self.q, self.p) == 1
    assert self.md in ("SHA-1", "SHA-224", "SHA-256", "SHA-384", "SHA-512")
    if self.md == "SHA-1":
      assert self.qbits == 160
    elif self.md == "SHA-224":
      assert self.qbits in (160, 224)
    else:
      assert self.qbits in (160, 224, 256)

  @util.type_check
  def digest(self, message: bytes) -> int:
    """Returns the truncated hash converted into an integer.

    Args:
      message: the message to sign
    """
    h = util.hash(self.md, message)
    shift = 8 * len(h) - self.qbits
    return int.from_bytes(h, "big") >> shift

  def encode(self) -> bytes:
    """Returns the ASN encoding of this key."""
    return asn.encode(self.asn_struct())

  def encode_hex(self):
    """Returns the ASN encoding of this key in hex."""
    return asn.encode_hex(self.asn_struct())

  def asn_struct(self) -> asn.AsnStructure:
    raise NotImplementedError("DsaKey is an abstract class")


class DsaPublicKey(DsaKey):
  """A DSA public key"""

  schema =  {
    "type" : {
      "type" : str,
      "enum" : ["DsaPublicKey"],
      "desc" : "the key type",
    },
    "keySize" : {
      "type" : int,
      "desc" : "the key size in bits",
    },
    "p" : {
      "type" : AST.BigInt,
      "desc" : "the modulus p",
    },
    "q" : {
      "type" : AST.BigInt,
      "desc" : "the order of the generator g",
    },
    "g" : {
      "type" : AST.BigInt,
      "desc" : "the generator of the multiplicative subgroup",
    },
    "y" : {
      "type" : AST.BigInt,
      "desc" : "the public key value",
    }
  }

  def __init__(self,
               md: str,
               p: int,
               q: int,
               g: int,
               y: int,
               is_valid: bool = True):
    """Constructs a new DSA key.

    DsaKey is the base class for DsaPublicKey and DsaPrivateKey.
    The class itself should not be instantiated.

    Args:
      md: the hash function for hashing the key (e.g. "SHA-256")
      p: the size of the prime field
      q: the size of the multiplicative subgroup generated by g
      g: a generator of the muliplicative subgroup
      y: the public key
      is_valid: indicates whether the key is valid
    """
    super().__init__(md, p, q, g)
    self.y = y
    if is_valid:
      self.check()

  def check(self):
    """Some simple self checks."""
    self.check_params()
    # TODO: more tests: check key sizes

  def verify_raw(self, r: Any, s: Any, message: bytes) -> bool:
    """Verifies a signature.

    Args:
      r: the first part of the signature
      s: the second part of the signature
      message: the message that was signed
    Returns: True if the signature is valid, False otherwise
    """
    h = self.digest(message)
    if not isinstance(r, int):
      return False
    if not (0 < r < self.q):
      return False
    if not isinstance(s, int):
      return False
    if not (0 < s < self.q):
      return False
    w = pow(s, -1, self.q)
    u1 = h * w % self.q
    u2 = r * w % self.q
    v = pow(self.g, u1, self.p) * pow(self.y, u2, self.p) % self.p % self.q
    return v == r

  def as_struct(self) -> dict[str, Any]:
    """Returns this key as a dictionary.

    Returns:
      a dictonary describing this key
    """
    res = collections.OrderedDict()
    res["type"] = "DsaPublicKey"
    res["keySize"] = self.p.bit_length()
    res["p"] = AST.BigInt(self.p)
    res["q"] = AST.BigInt(self.q)
    res["g"] = AST.BigInt(self.g)
    res["y"] = AST.BigInt(self.y)
    return res

  def asn_struct(self) -> asn.AsnStructure:
    """based on the SUN provider"""
    oid = asn.Oid("2a8648ce380401")
    # RFC 5912, page 24
    dsa_params = asn.Sequence(
        p = self.p,
        q = self.q,
        g = self.g)
    # AlgorithmIdentifier: RFC 5912, section 2
    alg_id = asn.Sequence(
        algorithm = oid,
        parameters = dsa_params)
    return asn.Sequence(
        algorithm = alg_id,
        subjectPublicKey = asn.BitString(self.y))

  # TODO: Is this also defined for private keys?
  def encode_b64(self):
    """Returns the urlsafe encoding of this key.

    This encoding is used by jwk.
    """
    return asn.encode_b64(self.asn_struct())

  def pem(self):
    """Return the PEM encoding of this key."""
    return pem_util.public_key_pem(self.encode())


class DsaPrivateKey(DsaKey):
  """A DSA private key.

     This implementation of DSA must only be used for testing
     rsp. for generating test vectors. It has not been checked for
     flaws and in some cases may even avoid necessary checks so that
     it can be used for flawed test vectors."""

  schema =  {
    "type" : {
      "type" : str,
      "enum" : ["DsaPrivateKey"],
      "desc" : "the key type",
    },
    "keySize" : {
      "type" : int,
      "desc" : "the key size in bits",
    },
    "p" : {
      "type" : AST.BigInt,
      "desc" : "the modulus p",
    },
    "q" : {
      "type" : AST.BigInt,
      "desc" : "the order of the generator g",
    },
    "g" : {
      "type" : AST.BigInt,
      "desc" : "the generator of the multiplicative subgroup",
    },
    "x" : {
      "type" : AST.BigInt,
      "desc" : "the private key value",
    },
    "y" : {
      "type" : AST.BigInt,
      "desc" : "the public key value",
    }
  }

  def __init__(self, md, p, q, g, x, valid=True):
    super().__init__(md, p, q, g)
    self.x = x
    self.y = pow(g, x, p)
    self.valid = valid
    self.pubkey = None
    if self.valid:
      self.check()

  def check(self):
    self.check_params()


  @util.type_check
  def sign_raw(self, message: bytes, seed: bytes = b"19235jhg21"):
    """Signs a message and returns a tuple (r, s).

    Args:
      message: the message to sign
      seed: if a seed is given then a deterministic signature
        is generated.
    Returns:
      the signature as a tuple (r, s)
    """
    h = self.digest(message)
    ctr = 0
    while True:
      inp = b"%x:%x:" % (self.x, ctr) + seed
      k = prand.randrange(1, self.q, inp, message)
      r = pow(self.g, k, self.p) % self.q
      if r == 0: continue
      kinv = pow(k, -1, self.q)
      s = kinv * (h + self.x * r) % self.q
      if s == 0: continue
      return r, s

  def public_key(self) -> DsaPublicKey:
    """Returns the public key corresponding to this key."""
    if self.pubkey is None:
      self.pubkey = DsaPublicKey(self.md, self.p, self.q, self.g, self.y,
                                 self.valid)
    return self.pubkey

  def as_struct(self) -> dict[str, Any]:
    """Returns this key as a dictionary."""
    res = collections.OrderedDict()
    res = {
        "type": "DSAPrivateKey",
        "p": AST.BigInt(self.p),
        "q": AST.BigInt(self.q),
        "g": AST.BigInt(self.g),
        "x": AST.BigInt(self.x),
        "y": AST.BigInt(self.y),
        "keySize": self.p.bit_length()
    }
    return res

  def asn_struct(self) -> asn.AsnStructure:
    """Returns the ASN structure of this key.

    The ASN structure is defined in RFC 5912.
    """
    oid = asn.Oid("2a8648ce380401")
    # RFC 5912, page 24
    dsa_params = asn.Sequence(
        p = self.p,
        q = self.q,
        g = self.g)
    alg_id = asn.Sequence(
        algorithm = oid,
        parameters = dsa_params)
    # RFC 5912, page 56
    private_key_info = asn.Sequence(
        version = 0,
        privateKeyAlgorithm = alg_id,
        privateKey = asn.OctetString(asn.encode_hex(self.x)))
    return private_key_info


def new_params(psize: int, qsize: int) -> tuple[int, int, int]:
  """Generate new parameters for DSA.

  Args:
    psize: the bit length of the field size
    qsize: the bit length of the size of the subgroup

  Returns:
    a tuple (p, q, g), where p is the size of the field,
    q is the size of the subgroup and g is a generator of the
    subgroup.
  """
  # Sanity check for the sizes
  if not (160 <= qsize <= 512):
    raise ValueError("invalid size for q")
  if not (1024 <= psize <= 2**14):
    raise ValueError("invalid size for p")
  q = pseudoprimes.random_prime(2**(qsize - 1), 2**qsize)
  p = pseudoprimes.random_prime_in_residue_class(2**(psize - 1), 2**(psize), q,
                                                 1)
  h = 2
  while True:
    g = pow(2, p//q, p)
    if g == 1:
      h += 1
      continue
    # sanify check
    assert pow(g, q, p) == 1
    return p, q, g


def gen_params():
  """This is the generator that was used for the precomputed test keys."""

  def f(m: int, indent: int = 10, sz: int = 64):
    """Formats an integer.

    This function represent the integer as a valid python expression using
    multiple lines. E.g. f(1234567890123456789, 2, 10) gives

      int("1234567890"
          "123456789")

    Args:
      m: the integeger to format
      indent: the indent at the beginning of the line
      sz: the size of the chunks.

    Returns:
      The formatted integer.
    """
    s = str(m)
    t = [repr(s[i:i+sz]) for i in range(0, len(s), sz)]
    return "int(" + ("\n" + " "*indent).join(t) + ")"

  # Generates parameters for the DSA parameters proposed by NIST.
  for psize, qsize in [
    (1024, 160),
    (2048, 224),
    (2048, 256),
    (3072, 256),
    (4096, 256)]:
    p, q, g = [f(v) for v in new_params(psize, qsize)]
    print("    (%d, %d) : (\n      %s,\n      %s,\n      %s)),"
          % (psize, qsize, p, q, g))
