# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import AST
import collections
import kdf
import producer
import test_vector
import typing
import prand
import util
from typing import Optional

SUPPORTED_KDFS = ["KDF1", "KDF2"]

# TODO:
#   https://www.shoup.net/iso/std4.pdf uses just SHA-1.
#   Are there other references that extend these functions to more hashes.
SUPPORTED_HASHES = ["SHA-1"]

class KdfTestVector(test_vector.TestVector):
  """A test vector for key derivation functions.

  I.e., these are deterministic functions that take a seed and
  a size as input and generate a pseudorandom output depending
  on the seed. (The size may simply determine the length of the
  pseudorandom output or may change the pseudorandom stream).
  """
  test_attributes = ["seed", "size", "okm"]
  schema = {
      "seed": {
          "type": AST.HexBytes,
          "desc": "the seed",
      },
      "size": {
          "type": int,
          "desc": "the size of the output in bytes",
      },
      "okm": {
          "type": AST.HexBytes,
          "desc": "the generated bytes (output key material)",
      },
  }

  def index(self):
    return len(self.seed)

class KdfTest(test_vector.TestType):
  """Test vectors of type KdfTest are intended to verify a key

     derivation function.

     Key derivation function differ by the number of arguments that
     are passed in. This type of test vector assumes that the
     key derivation function takes two arguments: a seed and an output
     size.
  """

class KdfTestGroup(test_vector.TestGroup):
  """A test group for key derivation functions that take 2 arguments

     (seed, size) as input.
  """
  algorithm = "KDF"
  testtype = KdfTest
  vectortype = KdfTestVector
  schema = {
      "keySize": {
          "type": int,
          "desc": "the size of the seed in bits",
      },
  }

  def __init__(self, key_size: int):
    """Construct a new test group for keys of a given size.

      Args:
        key_size: the size of the seed in bits.
    """
    super().__init__()
    self.keySize = key_size

  def as_struct(self, sort_by=None):
    if sort_by is None:
      sort_by = "comment"
    group = collections.OrderedDict()
    group["type"] = self.testtype
    group["keySize"] = 8 * self.keySize
    group["tests"] = self.get_all_vectors(sort_by=sort_by)
    return group

class KdfTestGenerator(test_vector.TestGenerator):
  """A generator for KDF test vectors."""
  def __init__(self, namespace):
    self.args = namespace
    self.sha = namespace.sha
    self.kdf_name = namespace.kdf
    self.name = self.kdf_name + self.sha  # Check names
    self.kdf = None
    if self.sha == "SHA-1":
      if self.kdf_name == "KDF1":
        self.kdf = kdf.kdf1sha1
        self.maxsize = 2**32 - 1
      elif self.kdf_name == "KDF2":
        self.kdf = kdf.kdf2sha1
        self.maxsize = 2**32 - 1
    if self.kdf is None:
      raise ValueError("KDF is not supported")
    self.test = test_vector.Test(self.name)
    super().__init__()

  def new_testgroup(self, idx):
    return KdfTestGroup(idx)

  @util.type_check
  def gen_test(self,
               seed: bytes,
               size: int,
               expected: typing.Optional[bytes] = None,
               flags=None,
               comment=""):
    if flags is None:
      flags = []
    if size > self.maxsize:
      okm = self.kdf(seed, size, False)
      flags.append(
          self.footnote(
              "SizeTooLarge",
              "The output size of HKDF is limited to 255*size of the hash digest"
          ))
      result = "invalid"
    else:
      okm = self.kdf(seed, size)
      result = "valid"
    if expected is not None:
      assert okm == expected
    test = KdfTestVector()
    test.comment = comment
    test.seed = seed
    test.size = size
    test.okm = okm
    test.result = result
    test.flags = flags
    self.add_test(test)

  def generate_known_test_vectors(self):
    pass
    # for t in hkdf_ktv.get_vectors(self.args.sha):
    #  h, ikm, salt, info, size, okm, comment = t
    #  assert h == self.args.sha
    #  self.gen_test(ikm, salt, info, size, okm, comment=comment)

  def generate_pseudorandom(self,
                            cnt: int,
                            seed_sizes: list[int],
                            output_sizes: list[int],
                            comment: str = "",
                            pr_seed: bytes = "",
                            flags: Optional[list[str]] = None):
    """
    Generates pseudorandom test vectors.
    Args:
        cnt: the number of test vectors generated
        seed_sizes: the seed sizes in bytes
        output_sizes: the output sizes in bytes
        comment: information about the test vector
        pr_seed: a seed used in the pseudorandom generation
        flags: flags added to the test vectors
    """
    for seed_size in seed_sizes:
      for output_size in output_sizes:
        for i in range(cnt):
          ident = b"%s %d %d %d" % (pr_seed, seed_size, output_size, i)
          seed = prand.randbytes(seed_size, b"key:", ident)
          self.gen_test(seed=seed, size=output_size, comment=comment,
                        flags=flags)


  def generate_all(self):
    self.generate_known_test_vectors()
    # typical
    self.generate_pseudorandom(
        cnt=1,
        seed_sizes=[16, 20, 32],
        output_sizes=[20, 42, 64, 130],
        pr_seed=b"9812jkls2j")
    # seed size > block size of hash. Some KDFs hash long seeds.
    self.generate_pseudorandom(
        cnt=1,
        seed_sizes=[65, 80],
        output_sizes=[42],
        pr_seed=b"1lk2j24sse",
        comment="long seed size")


class KdfProducer(producer.Producer):

  def parser(self):
    res = self.default_parser()
    res.add_argument("--kdf", type=str, choices=SUPPORTED_KDFS)
    res.add_argument("--sha", type=str, choices=SUPPORTED_HASHES)
    return res

  def generate_test_vectors(self, namespace):
    tv = KdfTestGenerator(namespace)
    tv.generate_all()
    return tv.test


# DEPRECATED: Use Producer.produce() instead
def main(namespace):
  KdfProducer().produce(namespace)


if __name__ == "__main__":
  KdfProducer().produce_with_args()
