# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import asn
import AST
import base64
import ec
import ec_binary
import group
import mod_arith
import oid
from typing import Optional, Any, Union
import util

Point = tuple[int, int]

# Defined in group to avoid circular imports.
EcGroup = group.EcGroup

class EcPrimeGroup(EcGroup):
  """Defines a cyclic group over a prime order elliptic curve.

  The curve is in Weierstrass form. Instances contain a generator for
  this group. Hence instances of this class contain the same information as
  the java class ECParameterSpec.
  """
  def __init__(self, p: int, n: int, a: int, b: int, g: tuple[int, int],
               h:int = 1, repr: str=""):
    """Constructs a new cyclic group of points over an elliptic curve.

    Args:
        p: the order of the underlying field
        n: the order of the group generated by g
        a: the coefficient a of the curve equation
        b: the coefficient b of the curve equation
        g: the generator
        h: the co-coefficient (i.e. n*h is the number of points on the curve
          modulo p)
        repr: the representation for the points on the curve. Currently this is
          either "affine" or "jacobian"
    """
    self.name = None
    self.oid = None
    self.p = p
    self.n = n
    self.a = a % p
    self.b = b % p
    self.g = g
    self.h = h
    self.encoding_length = (self.n.bit_length() + 7) // 8
    if repr == "jacobian":
      self.curve = ec.EcModJacobian(a, b, p)
    elif repr == "affine":
      self.curve = ec.EcMod(a, b, p)
    else:
      # Use a default representation
      self.curve = ec.EcModJacobian(a, b, p)

  def field_size(self) -> int:
    """Return the number of elements of the underlying field."""
    return self.p

  def get_y(self, x: int) -> Optional[int]:
    """Returns a y-coordinate for a point with x-coordinate x.

    Args:
      x: the x-coordinate of the point

    Returns:
      a corresponding y-coordinate if a point with coordinate x exists,
      of None otherwise.
    """
    ysqr = ((x * x + self.a) * x + self.b) % self.p
    return mod_arith.modsqrt(ysqr, self.p)

  def get_ys(self, x: int) -> list[int]:
    """Returns a list of y-coordinates for a point with x-coordinate x.

    Args:
      x: the x-coordinate

    Returns:
      a list of y-coordinates. The list is empty if no point exists.
    """
    y = self.get_y(x)
    if y is None:
      return []
    elif y == 0:
      return [y]
    else:
      return [y, self.p - y]

  def encode_field_element(self, x: int) -> bytes:
    """Encodes an element of the field.

    Defined in Section 2.3.5 of sec1-v2.pdf

    Args:
      x: the element to encode

    Returns:
      the encoding. This is a fixed-length bigendian encoding
      of the integer x.
    """
    size = (self.p.bit_length() + 7) // 8
    return x.to_bytes(size, "big")

  def encode_uncompressed(self, pt: Point) -> bytes:
    """Encodes a point using an uncompressed representation.

    Args:
      point: The point to encode

    Returns:
      the encoded point. The encoding has the format
      4 || x || y, where x, y are fixed-length bigendian encodings
      of the x and y coordinates of the point.
    """
    x, y = pt
    res = bytes([4])
    res += self.encode_field_element(x)
    res += self.encode_field_element(y)
    return res

  def encode_compressed(self, pt: Point) -> bytes:
    """Encodes a point using a compressed representation.

    Args:
      pt: the point to encode

    Returns:
      the encoded point. This is either 2 || x or 3 || x, where the first
      byte determines the parity of y and the remainder is a fixed-length
      bigendian encoding of the x-coordinate.
    """
    x, y = pt
    y = int(y)
    res = bytes([2 + y % 2])
    res += self.encode_field_element(x)
    return res

  def params(self) -> list[Any]:
    """Returns the parameters of the EC group."""

    return [self.name, self.p, self.n, self.a, self.b, self.g, self.h, self.oid]

  def __eq__(self, other):
    if not isinstance(other, EcPrimeGroup):
      return False
    return self.params() == other.params()

  def __ne__(self, other):
    return not self == other

  def verify_name(self):
    """Returns true if this is a known named group.

    This method is overriden by subclasses.
    """
    return False

  def get_oid_hex(self) -> Optional[str]:
    """Returns the OID of the curve as hexadecimal string.

    This method verifies that the curve parameters are correct and represent
    the curve with the given OID. I.e., when the test vector generation modifies
    any of the parameters of the curve then the check fails and the result of
    this method is None.

    Returns:
      the OID of the curve as a hexadecimal string or None if
      no OID is known or the curve parameters have been modified.
    """
    oid = self.get_oid()
    if oid:
      return oid.hex()
    return None

  def get_oid(self) -> Optional[oid.Oid]:
    """Returns the OID of the curve.

    This method verifies that the curve parameters are correct and represent
    the curve with the given OID. I.e., when the test vector generation modifies
    any of the parameters of the curve then the check fails and the result of
    this method is None.

    Returns:
      the OID of the curve or None if
      no OID is known or the curve parameters have been modified.
    """
    if self.verify_name():
      return self.oid
    else:
      return None


  def get_point(self, x: int, y: int) -> ec.EcPoint:
    """Returns a point on the curve

    Args:
      x: the x-coordinate
      y: the y-coordinate

    Returns:
      the point (x, y)
    """
    return self.curve.point(x, y, verify=True)

  def generator(self) -> ec.EcPoint:
    return self.get_point(self.g[0], self.g[1])

  def zero(self) -> ec.EcPoint:
    return self.curve.zero()

  def is_on_curve(self, x: int, y: int) -> bool:
    """Determines if (x, y) is a point on the curve.

    Args:
      x: the x-coordinate of the point
      y: the y-coordinate of the point

    Returns:
      True if (x, y) is a point on the curve
    """
    return self.curve.is_on_curve(x, y)

  def asn_struct(self, use_name: bool = False):
    """Returns the ASN structure of an unnamed curve.

    https://www.secg.org/sec1-v2.pdf  p.103

    Args:
      use_name: if True attempts to use an OID for the curve
    Returns:
      the ASN structure of the curve.
    """
    version = 1
    # prime-field, SEC 1 p.101
    fp = asn.Oid("2a8648ce3d0101")

    field = asn.Sequence(prime_field=fp, prime_p=self.p)
    size = (self.p.bit_length() + 7) // 8
    a = asn.OctetStringFromInt(self.a % self.p, size)
    b = asn.OctetStringFromInt(self.b, size)
    curve = asn.Sequence(a=a, b=b)
    g_octets = self.encode_uncompressed(self.g)
    g = asn.OctetString(g_octets)
    # SpecifiedECDomain, SEC 1 p.103
    # Additional parameters are possible (e.g. hash used for generating
    # the EC parameters)
    if self.h:
      ecparams = asn.Sequence(
          version=version,
          fieldID=field,
          curve=curve,
          base=g,
          order=self.n,
          cofactor=self.h)
    else:
      ecparams = asn.Sequence(
          version=version, fieldID=field, curve=curve, base=g, order=self.n)
    return ecparams

  def as_struct(self, use_name: bool = False) -> dict[str, Any]:
    """Returns the curve as a dictionary.

    Test vectors typically contain multiple representation of the elliptic
    curves. (E.g. ASN encoded curves, PEM encoding, and a dictionary
    with all the parameters).
    """
    return {
      "type" : "PrimeOrderCurve",
      "p" : AST.BigInt(self.p),
      "a" : AST.BigInt(self.a),
      "b" : AST.BigInt(self.b),
      "gx" : AST.BigInt(self.g[0]),
      "gy" : AST.BigInt(self.g[1]),
      "h" : self.h,
      "n" : AST.BigInt(self.n)}

  def jwk(self):
    """Returns the jwk name of the curve or None if no name is registered."""
    return self.jwk_name

class EcUnnamedGroup(EcPrimeGroup):
  """An unamed EC group"""
  schema = {
    "type" : {
       "type" : str,
       "enum" : ["PrimeOrderCurve"],
       "desc" : "an unnamed EC group over a prime field in Weierstrass form",
     },
    "p" : {
       "type" : AST.BigInt,
       "desc" : "the order of the underlying field",
    },
    "n" : {
       "type" : AST.BigInt,
       "desc" : "the order of the generator",
    },
    "a" : {
       "type" : AST.BigInt,
       "desc" : "coefficient a of the elliptic curve equation",
    },
    "b" : {
       "type" : AST.BigInt,
       "desc" : "coefficient b of the elliptic curve equation",
    },
    "gx" : {
       "type" : AST.BigInt,
       "desc" : "the x-coordinate of the generator",
    },
    "gy" : {
       "type" : AST.BigInt,
       "desc" : "the y-coordinate of the generator",
    },
    "h" : {
       "type" : int,
       "desc" : "the cofactor",
    },
  }

class EcNamedGroup(EcPrimeGroup):
  """A named EC group over a prime order field."""

  type_info = {
    "type" : str,
    "desc" : "the name of the EC group"
  }

  def __init__(self,
               name: str,
               p: int,
               n: int,
               a: int,
               b: int,
               g: tuple[int, int],
               h: int = 1,
               curve_oid: Optional[Union[str, oid.Oid]] = None,
               jwk_name: Optional[str] = None,
               ansi_name: Optional[str] = None,
               ref: Optional[str] = None):
    super().__init__(p, n, a, b, g, h)
    self.name = name
    if isinstance(curve_oid, str):
      curve_oid = oid.frombytes(bytes.fromhex(curve_oid))
    self.oid = curve_oid
    self.jwk_name = jwk_name
    self.ansi_name = ansi_name
    self.ref = ref

  def as_unnamed_group(self) -> EcPrimeGroup:
    """Returns this group as unnamed group.

    The EC operations are still the same, but the encodings
    are different.
    """
    return EcUnnamedGroup(self.p, self.n, self.a, self.b, self.g, self.h)

  def verify_name(self) -> bool:
    """returns true if this.name and this.params() match"""
    return self == named_curve(self.name)

  def asn_struct(self, use_name: bool = True) -> Any:
    oid = self.get_oid()
    if oid and use_name:
      return asn.Oid(oid)
    else:
      return self.as_unnamed_group().asn_struct(use_name=False)

  def as_struct(self, use_name: bool = True) -> dict[str, Any]:
    if use_name and self.verify_name():
      return self.name
    else:
      self.as_unnamed_group().as_struct(use_name=False)


class Isomorphism:
  pass

class BrainpoolIsomorphism(Isomorphism):
  """Brainpool curves and their twist are isomorphic.

  This class implements the isomorphism defined on page 6 or RFC 5639."""
  def __init__(self, A, B, Z):
    # sanity checks
    assert isinstance(A, EcNamedGroup)
    assert isinstance(B, EcNamedGroup)
    assert isinstance(Z, int) or isinstance(Z, long)
    assert A.p == B.p
    assert A.n == B.n
    self.A = A
    self.B = B
    self.Z = Z
    self.invZ = pow(Z, -1, A.p)

  def fromAtoB(self, P):
    if not P:
      return B.zero()
    x,y = P.affine()
    x2 = x*self.Z**2 % self.B.p
    y2 = y*self.Z**3 % self.B.p
    return self.B.get_point(x2, y2)

  def fromBtoA(self, P):
    x,y = P.affine()
    x2 = x*self.invZ**2 % self.A.p
    y2 = y*self.invZ**3 % self.A.p
    return self.A.get_point(x2, y2)

curveP256 = EcNamedGroup(
    name="secp256r1",
    jwk_name="P-256",
    ansi_name="X9_62_prime256v1",
    ref="ANSI X9.62",
    curve_oid="2a8648ce3d030107",
    p=int("1157920892103562487626974469494075735300861434152903141955336313"
          "08867097853951"),
    n=int("1157920892103562487626974469494075735299969552241357603424222590"
          "61068512044369"),
    a=-3,
    b=0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b,
    g=(0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296,
       0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5))

curveP224 = EcNamedGroup(
    name="secp224r1",
    curve_oid=oid.fromstr("1.3.132.0.33"),
    ref="ANSI X9.62",
    p=26959946667150639794667015087019630673557916260026308143510066298881,
    n=26959946667150639794667015087019625940457807714424391721682722368061,
    a=-3,
    b=0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4,
    g=(0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21,
       0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34),
)

curveP384 = EcNamedGroup(
    name="secp384r1",
    jwk_name="P-384",
    ref="ANSI X9.62",
    curve_oid=oid.fromstr("1.3.132.0.34"),
    p=int("3940200619639447921227904010014361380507973927046544666794829340"
          "4245721771496870329047266088258938001861606973112319"),
    n=int("3940200619639447921227904010014361380507973927046544666794690527"
          "9627659399113263569398956308152294913554433653942643"),
    a=-3,
    b=int(
        "b3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875a"
        "c656398d8a2ed19d2a85c8edd3ec2aef", 16),
    g=(int(
        "aa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a38"
        "5502f25dbf55296c3a545e3872760ab7", 16),
       int(
           "3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c0"
           "0a60b1ce1d7e819d7a431d7c90ea0e5f", 16)))

curveP521 = EcNamedGroup(
    name="secp521r1",
    jwk_name="P-521",
    ref="ANSI X9.62",
    curve_oid=oid.fromstr("1.3.132.0.35"),
    p=int("6864797660130609714981900799081393217269435300143305409394463459"
          "1855431833976560521225596406614545549772963113914808580371219879"
          "99716643812574028291115057151"),
    n=int("6864797660130609714981900799081393217269435300143305409394463459"
          "1855431833976553942450577463332171975329639963713633211138647686"
          "12440380340372808892707005449"),
    a=-3,
    b=int(
        "51953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109"
        "e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f"
        "00", 16),
    g=(int(
        "c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3d"
        "baa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd"
        "66", 16),
       int(
           "11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e6"
           "62c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16"
           "650", 16)))

secp256k1 = EcNamedGroup(
    name="secp256k1",
    curve_oid="2b8104000a",
    ref="https://www.secg.org/sec2-v2.pdf",
    jwk_name="secp256k1",  # RFC 8812
    p=2**256 - 2**32 - 977,
    a=0,
    b=7,
    g=(0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798,
       0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8),
    n=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141,
    h=1)

secp192k1 = EcNamedGroup(
    name="secp192k1",
    curve_oid=oid.fromstr("1.3.132.0.31"),
    ref="ANSI X9.62",
    p=2**192 - 2**32 - 2**12 - 2**8 - 2**7 - 2**6 - 2**3 - 1,
    a=0,
    b=3,
    g=(0xDB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D,
       0x9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D),
    n=0xFFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D,
    h=1)

# also known as prime192v1
secp192r1 = EcNamedGroup(
    name="secp192r1",
    curve_oid="2a8648ce3d030101",  #  { ansi-X9-62 curves(3) prime(1) 1 }
    ansi_name="ansiX9p192r1",
    ref="ANSI X9.62",
    p=2**192 - 2**64 - 1,
    a=-3,
    b=0x64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1,
    g=(0x188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012,
       0x7192B95FFC8DA78631011ED6B24CDD573F977A11E794811),
    n=0xFFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831,
    h=1)

secp224k1 = EcNamedGroup(
    name="secp224k1",
    ref="ANSI X9.62",
    curve_oid=oid.fromstr("1.3.132.0.32"),
    p=2**224 - 2**32 - 6803,
    a=0,
    b=5,
    g=(0xA1455B334DF099DF30FC28A169A467E9E47075A90F7E650EB6B7A45C,
       0x7E089FED7FBA344282CAFBD6F7E319F7C0B0BD59E2CA4BDB556D61A5),
    n=0x010000000000000000000000000001DCE8D2EC6184CAF0A971769FB1F7,
    h=1)

secp160k1 = EcNamedGroup(
    name="secp160k1",
    ref="https://www.secg.org/SEC2-Ver-1.0.pdf",
    curve_oid="2b81040009",
    p=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73,
    a=0,
    b=7,
    g=(0x3B4C382CE37AA192A4019E763036F4F5DD4D7EBB,
       0x938CF935318FDCED6BC28286531733C3F03C4FEE),
    n=0x100000000000000000001B8FA16DFAB9ACA16B6B3,
    h=1)

secp160r1 = EcNamedGroup(
    name="secp160r1",
    curve_oid="2b81040008",
    ref="https://www.secg.org/SEC2-Ver-1.0.pdf",
    p=2**160 - 2**31 - 1,
    a=-3,
    b=0x1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45,
    g=(0x4A96B5688EF573284664698968C38BB913CBFC82,
       0x23A628553168947D59DCC912042351377AC5FB32),
    n=0x0100000000000000000001F4C8F927AED3CA752257,
    h=1)

secp160r2 = EcNamedGroup(
    name="secp160r2",
    curve_oid="2b8104001e",
    ref="https://www.secg.org/SEC2-Ver-1.0.pdf",
    p=2**160 - 2**32 - 21389,
    a=-3,
    b=0xB4E134D3FB59EB8BAB57274904664D5AF50388BA,
    g=(0x52DCB034293A117E1F4FF11B30F7199D3144CE6D,
       0xFEAFFEF2E331F296E071FA0DF9982CFEA7D43F2E),
    n=0x0100000000000000000000351EE786A818F3A1A16B,
    h=1)

brainpoolP160r1 = EcNamedGroup(
    name="brainpoolP160r1",
    curve_oid="2b2403030208010101",
    ref="RFC 5639",
    p=0xE95E4A5F737059DC60DFC7AD95B3D8139515620F,
    a=0x340E7BE2A280EB74E2BE61BADA745D97E8F7C300,
    b=0x1E589A8595423412134FAA2DBDEC95C8D8675E58,
    g=(0xBED5AF16EA3F6A4F62938C4631EB5AF7BDBCDBC3,
       0x1667CB477A1A8EC338F94741669C976316DA6321),
    n=0xE95E4A5F737059DC60DF5991D45029409E60FC09,
    h=1)

brainpoolP160t1 = EcNamedGroup(
    name="brainpoolP160t1",
    curve_oid="2b2403030208010102",
    ref="RFC 5639",
    p=0xE95E4A5F737059DC60DFC7AD95B3D8139515620F,
    a=0xE95E4A5F737059DC60DFC7AD95B3D8139515620C,
    b=0x7A556B6DAE535B7B51ED2C4D7DAA7A0B5C55F380,
    g=(0xB199B13B9B34EFC1397E64BAEB05ACC265FF2378,
       0xADD6718B7C7C1961F0991B842443772152C9E0AD),
    n=0xE95E4A5F737059DC60DF5991D45029409E60FC09,
    h=1)

# Conversion of points from brainpoolP192r1 to brainpoolP192t1:
# F(x,y) := (x*Z^2 % p, y*Z^3 % p)
brainpoolP160Isomorphism = BrainpoolIsomorphism(
    brainpoolP160r1, brainpoolP160t1,
    0x24DBFF5DEC9B986BBFE5295A29BFBAE45E0F5D0B)

brainpoolP192r1 = EcNamedGroup(
    name="brainpoolP192r1",
    curve_oid="2b2403030208010103",
    ref="RFC 5639",
    p=0xC302F41D932A36CDA7A3463093D18DB78FCE476DE1A86297,
    a=0x6A91174076B1E0E19C39C031FE8685C1CAE040E5C69A28EF,
    b=0x469A28EF7C28CCA3DC721D044F4496BCCA7EF4146FBF25C9,
    g=(0xC0A0647EAAB6A48753B033C56CB0F0900A2F5C4853375FD6,
       0x14B690866ABD5BB88B5F4828C1490002E6773FA2FA299B8F),
    n=0xC302F41D932A36CDA7A3462F9E9E916B5BE8F1029AC4ACC1,
    h=1)

brainpoolP192t1 = EcNamedGroup(
    name="brainpoolP192t1",
    curve_oid="2b2403030208010104",
    ref="RFC 5639",
    p=0xC302F41D932A36CDA7A3463093D18DB78FCE476DE1A86297,
    a=0xC302F41D932A36CDA7A3463093D18DB78FCE476DE1A86294,
    b=0x13D56FFAEC78681E68F9DEB43B35BEC2FB68542E27897B79,
    g=(0x3AE9E58C82F63C30282E1FE7BBF43FA72C446AF6F4618129,
       0x097E2C5667C2223A902AB5CA449D0084B7E5B3DE7CCC01C9),
    n=0xC302F41D932A36CDA7A3462F9E9E916B5BE8F1029AC4ACC1,
    h=1)

# Conversion of points from brainpoolP192r1 to brainpoolP192t1:
# F(x,y) := (x*Z^2 % p, y*Z^3 % p)
brainpoolP192Isomorphism = BrainpoolIsomorphism(
    brainpoolP192r1, brainpoolP192t1,
    0x1B6F5CC8DB4DC7AF19458A9CB80DC2295E5EB9C3732104CB)

brainpoolP224r1 = EcNamedGroup(
    name="brainpoolP224r1",
    curve_oid="2b2403030208010105",
    ref="RFC 5639",
    p=0xD7C134AA264366862A18302575D1D787B09F075797DA89F57EC8C0FF,
    a=0x68A5E62CA9CE6C1C299803A6C1530B514E182AD8B0042A59CAD29F43,
    b=0x2580F63CCFE44138870713B1A92369E33E2135D266DBB372386C400B,
    g=(0x0D9029AD2C7E5CF4340823B2A87DC68C9E4CE3174C1E6EFDEE12C07D,
       0x58AA56F772C0726F24C6B89E4ECDAC24354B9E99CAA3F6D3761402CD),
    n=0xD7C134AA264366862A18302575D0FB98D116BC4B6DDEBCA3A5A7939F,
    h=1)

# Isomorphic to brainpoolP224r1, but uses a=-3
# E.g. if a library has a fast implementation for curves with a=-3, then
# brainpoolP224r1 can be implemented by first converting to brainpoolP224t1
# do the point multiplication there and then converting back.
brainpoolP224t1 = EcNamedGroup(
    name="brainpoolP224t1",
    curve_oid="2b2403030208010106",
    ref="RFC 5639",
    p=0xD7C134AA264366862A18302575D1D787B09F075797DA89F57EC8C0FF,
    a=0xD7C134AA264366862A18302575D1D787B09F075797DA89F57EC8C0FC,
    b=0x4B337D934104CD7BEF271BF60CED1ED20DA14C08B3BB64F18A60888D,
    g=(0x6AB1E344CE25FF3896424E7FFE14762ECB49F8928AC0C76029B4D580,
       0x0374E9F5143E568CD23F3F4D7C0D4B1E41C8CC0D1C6ABD5F1A46DB4C),
    n=0xD7C134AA264366862A18302575D0FB98D116BC4B6DDEBCA3A5A7939F,
    h=1)

# Conversion of points from brainpoolP224r1 to brainpoolP224t1:
# Z = 2DF271E14427A346910CF7A2E6CFA7B3F484E5C2CCE1C8B730E28B3F,
# F(x,y) := (x*Z^2 % p, y*Z^3 % p)
brainpoolP224Isomorphism = BrainpoolIsomorphism(
  brainpoolP224r1,
  brainpoolP224t1,
  0x2DF271E14427A346910CF7A2E6CFA7B3F484E5C2CCE1C8B730E28B3F)

brainpoolP256r1 = EcNamedGroup(
    name="brainpoolP256r1",
    curve_oid="2b2403030208010107",
    ref="RFC 5639",
    p=0xA9FB57DBA1EEA9BC3E660A909D838D726E3BF623D52620282013481D1F6E5377,
    a=0x7D5A0975FC2C3057EEF67530417AFFE7FB8055C126DC5C6CE94A4B44F330B5D9,
    b=0x26DC5C6CE94A4B44F330B5D9BBD77CBF958416295CF7E1CE6BCCDC18FF8C07B6,
    g=(0x8BD2AEB9CB7E57CB2C4B482FFC81B7AFB9DE27E1E3BD23C23A4453BD9ACE3262,
       0x547EF835C3DAC4FD97F8461A14611DC9C27745132DED8E545C1D54C72F046997),
    n=0xA9FB57DBA1EEA9BC3E660A909D838D718C397AA3B561A6F7901E0E82974856A7,
)

brainpoolP256t1 = EcNamedGroup(
    name="brainpoolP256t1",
    curve_oid="2b2403030208010108",
    ref="RFC 5639",
    p=0xA9FB57DBA1EEA9BC3E660A909D838D726E3BF623D52620282013481D1F6E5377,
    a=0xA9FB57DBA1EEA9BC3E660A909D838D726E3BF623D52620282013481D1F6E5374,
    b=0x662C61C430D84EA4FE66A7733D0B76B7BF93EBC4AF2F49256AE58101FEE92B04,
    g=(0xA3E8EB3CC1CFE7B7732213B23A656149AFA142C47AAFBC2B79A191562E1305F4,
       0x2D996C823439C56D7F7B22E14644417E69BCB6DE39D027001DABE8F35B25C9BE),
    n=0xA9FB57DBA1EEA9BC3E660A909D838D718C397AA3B561A6F7901E0E82974856A7,
    h=1)

# Conversion of points from brainpoolP256r1 to brainpoolP256t1:
# F(x,y) := (x*Z^2 % p, y*Z^3 % p)
brainpoolP256Isomorphism = BrainpoolIsomorphism(
  brainpoolP256r1,
  brainpoolP256t1,
  0x3E2D4BD9597B58639AE7AA669CAB9837CF5CF20A2C852D10F655668DFC150EF0)

brainpoolP320r1 = EcNamedGroup(
    name="brainpoolP320r1",
    curve_oid="2b2403030208010109",
    ref="RFC 5639",
    p=int(
        "D35E472036BC4FB7E13C785ED201E065F98FCFA6F6F40DEF4F92B9EC7893EC28"
        "FCD412B1F1B32E27", 16),
    a=int(
        "3EE30B568FBAB0F883CCEBD46D3F3BB8A2A73513F5EB79DA66190EB085FFA9F4"
        "92F375A97D860EB4", 16),
    b=int(
        "520883949DFDBC42D3AD198640688A6FE13F41349554B49ACC31DCCD88453981"
        "6F5EB4AC8FB1F1A6", 16),
    g=(int(
        "43BD7E9AFB53D8B85289BCC48EE5BFE6F20137D10A087EB6E7871E2A10A599C7"
        "10AF8D0D39E20611", 16),
       int(
           "14FDD05545EC1CC8AB4093247F77275E0743FFED117182EAA9C77877AAAC6AC7"
           "D35245D1692E8EE1", 16)),
    n=int(
        "D35E472036BC4FB7E13C785ED201E065F98FCFA5B68F12A32D482EC7EE8658E9"
        "8691555B44C59311", 16),
    h=1)

# Z = 15F75CAF668077F7E85B42EB01F0A81FF56ECD6191D55CB82B7D861458A18F
#      EFC3E5AB7496F3C7B1
brainpoolP320t1 = EcNamedGroup(
    name="brainpoolP320t1",
    curve_oid="2b240303020801010a",
    ref="RFC 5639",
    p=int(
        "D35E472036BC4FB7E13C785ED201E065F98FCFA6F6F40DEF4F92B9EC7893EC28"
        "FCD412B1F1B32E27", 16),
    a=int(
        "D35E472036BC4FB7E13C785ED201E065F98FCFA6F6F40DEF4F92B9EC7893EC"
        "28FCD412B1F1B32E24", 16),
    b=int(
        "A7F561E038EB1ED560B3D147DB782013064C19F27ED27C6780AAF77FB8A547"
        "CEB5B4FEF422340353", 16),
    g=(int(
        "925BE9FB01AFC6FB4D3E7D4990010F813408AB106C4F09CB7EE07868CC136F"
        "FF3357F624A21BED52", 16),
       int(
           "63BA3A7A27483EBF6671DBEF7ABB30EBEE084E58A0B077AD42A5A0989D1EE7"
           "1B1B9BC0455FB0D2C3", 16)),
    n=int(
        "D35E472036BC4FB7E13C785ED201E065F98FCFA5B68F12A32D482EC7EE8658"
        "E98691555B44C59311", 16),
    h=1)

brainpoolP384r1 = EcNamedGroup(
    name="brainpoolP384r1",
    curve_oid="2b240303020801010b",
    ref="RFC 5639",
    p=int(
        "8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B412B1DA197FB711"
        "23ACD3A729901D1A71874700133107EC53", 16),
    a=int(
        "7BC382C63D8C150C3C72080ACE05AFA0C2BEA28E4FB22787139165EFBA91F9"
        "0F8AA5814A503AD4EB04A8C7DD22CE2826", 16),
    b=int(
        "04A8C7DD22CE28268B39B55416F0447C2FB77DE107DCD2A62E880EA53EEB62"
        "D57CB4390295DBC9943AB78696FA504C11", 16),
    g=(int(
        "1D1C64F068CF45FFA2A63A81B7C13F6B8847A3E77EF14FE3DB7FCAFE0CBD10"
        "E8E826E03436D646AAEF87B2E247D4AF1E", 16),
       int(
           "8ABE1D7520F9C2A45CB1EB8E95CFD55262B70B29FEEC5864E19C054FF99129"
           "280E4646217791811142820341263C5315", 16)),
    n=int(
        "8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B31F166E6CAC0425"
        "A7CF3AB6AF6B7FC3103B883202E9046565", 16),
    h=1)

brainpoolP384t1 = EcNamedGroup(
    name="brainpoolP384t1",
    curve_oid="2b240303020801010c",
    ref="RFC 5639",
    p=int(
        "8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B412B1DA197FB711"
        "23ACD3A729901D1A71874700133107EC53", 16),
    a=int(
        "8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B412B1DA197FB711"
        "23ACD3A729901D1A71874700133107EC50", 16),
    b=int(
        "7F519EADA7BDA81BD826DBA647910F8C4B9346ED8CCDC64E4B1ABD11756DCE"
        "1D2074AA263B88805CED70355A33B471EE", 16),
    g=(int(
        "18DE98B02DB9A306F2AFCD7235F72A819B80AB12EBD653172476FECD462AAB"
        "FFC4FF191B946A5F54D8D0AA2F418808CC", 16),
       int(
           "25AB056962D30651A114AFD2755AD336747F93475B7A1FCA3B88F2B6A208CC"
           "FE469408584DC2B2912675BF5B9E582928", 16)),
    n=int(
        "8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B31F166E6CAC0425"
        "A7CF3AB6AF6B7FC3103B883202E9046565", 16),
    h=1)

brainpoolP384Isomorphism = BrainpoolIsomorphism(
  brainpoolP384r1,
  brainpoolP384t1,
  int("41DFE8DD399331F7166A66076734A89CD0D2BCDB7D068E44E1F378F41ECBAE"
      "97D2D63DBC87BCCDDCCC5DA39E8589291C", 16))

brainpoolP512r1 = EcNamedGroup(
    name="brainpoolP512r1",
    curve_oid="2b240303020801010d",
    ref="RFC 5639",
    p=int(
        "AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA703308"
        "717D4D9B009BC66842AECDA12AE6A380E62881FF2F2D82C68528AA6056583A48F3",
        16),
    a=int(
        "7830A3318B603B89E2327145AC234CC594CBDD8D3DF91610A83441CAEA9863"
        "BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117A72BF2C7B9E7C1AC4D77FC94CA",
        16),
    b=int(
        "3DF91610A83441CAEA9863BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117"
        "A72BF2C7B9E7C1AC4D77FC94CADC083E67984050B75EBAE5DD2809BD638016F723",
        16),
    g=(int(
        "81AEE4BDD82ED9645A21322E9C4C6A9385ED9F70B5D916C1B43B62EEF4D009"
        "8EFF3B1F78E2D0D48D50D1687B93B97D5F7C6D5047406A5E688B352209BCB9F822",
        16),
       int(
           "7DDE385D566332ECC0EABFA9CF7822FDF209F70024A57B1AA000C55B881F81"
           "11B2DCDE494A5F485E5BCA4BD88A2763AED1CA2B2FA8F0540678CD1E0F3AD80892",
           16)),
    n=int(
        "AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA703308"
        "70553E5C414CA92619418661197FAC10471DB1D381085DDADDB58796829CA90069",
        16),
    h=1)

brainpoolP512t1 = EcNamedGroup(
    name="brainpoolP512t1",
    curve_oid="2b240303020801010e",
    ref="RFC 5639",
    p=int(
        "AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA70330871"
        "7D4D9B009BC66842AECDA12AE6A380E62881FF2F2D82C68528AA6056583A48F3", 16),
    a=int(
        "AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA70330871"
        "7D4D9B009BC66842AECDA12AE6A380E62881FF2F2D82C68528AA6056583A48F0", 16),
    b=int(
        "7CBBBCF9441CFAB76E1890E46884EAE321F70C0BCB4981527897504BEC3E36A6"
        "2BCDFA2304976540F6450085F2DAE145C22553B465763689180EA2571867423E", 16),
    g=(int(
        "640ECE5C12788717B9C1BA06CBC2A6FEBA85842458C56DDE9DB1758D39C0313D"
        "82BA51735CDB3EA499AA77A7D6943A64F7A3F25FE26F06B51BAA2696FA9035DA", 16),
       int(
           "5B534BD595F5AF0FA2C892376C84ACE1BB4E3019B71634C01131159CAE03CEE9"
           "D9932184BEEF216BD71DF2DADF86A627306ECFF96DBB8BACE198B61E00F8B332",
           16)),
    n=int(
        "AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA70330870"
        "553E5C414CA92619418661197FAC10471DB1D381085DDADDB58796829CA90069", 16),
    h=1)

brainpoolP512Isomorphism = BrainpoolIsomorphism(
  brainpoolP512r1,
  brainpoolP512t1,
  int("12EE58E6764838B69782136F0F2D3BA06E27695716054092E60A80BEDB212B64"
      "E585D90BCE13761F85C3F1D2A64E3BE8FEA2220F01EBA5EEB0F35DBD29D922AB", 16))

# Based on Appendix D of
# https://tools.ietf.org/html/draft-shen-sm2-ecdsa-02
# There does not seem to be an OID, hence keys can only use the long
# encoding.
# The hash is defined here:
# https://tools.ietf.org/html/draft-sca-cfrg-sm3-02
# The Oid might be 1.2.156.10197.1.301.
# The draft uses 1.2.156.10197.1.301.1 (for signatures)
# and 1.2.156.10197.1.301.2 (for key exchange)
sm2group = EcNamedGroup(
    name="SM2",
    # curve_oid=oid.fromstr("1.2.156.10197.1.301"),
    ref="https://tools.ietf.org/html/draft-shen-sm2-ecdsa-02",
    p=0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF,
    a=0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC,
    b=0x28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93,
    n=0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123,
    g=(0x32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7,
       0xBC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0),
    h=1)

frp256v1 = EcNamedGroup(
    name="FRP256v1",
    ref="https://www.legifrance.gouv.fr/jorf/id/JORFTEXT000024668816",
    # TODO: needs checking since copy-paste does not work.
    curve_oid=oid.fromstr("1.2.250.1.223.101.256.1"),
    p=0xF1FD178C0B3AD58F10126DE8CE42435B3961ADBCABC8CA6DE8FCF353D86E9C03,
    a=0xF1FD178C0B3AD58F10126DE8CE42435B3961ADBCABC8CA6DE8FCF353D86E9C00,
    b=0xEE353FCA5428A9300D4ABA754A44C00FDFEC0C9AE4B1A1803075ED967B7BB73F,
    n=0xF1FD178C0B3AD58F10126DE8CE42435B53DC67E140D2BF941FFDD459C6D655E1,
    h=1,
    g=(0xB6B3D4C356C139EB31183D4749D423958C27D2DCAF98B70164C97A2DD98F5CFF,
       0x6142E0F7C8B204911F9271F0F3ECEF8C2701C307E8E4C9E183115A1554062CFB))

predefined_curves = [
    curveP224, curveP256, curveP384, curveP521,
    secp256k1, secp224k1,
    brainpoolP224r1, brainpoolP256r1, brainpoolP320r1, brainpoolP384r1,
    brainpoolP512r1,
    brainpoolP224t1, brainpoolP256t1, brainpoolP320t1, brainpoolP384t1,
    brainpoolP512t1,
    frp256v1]

weak_curves = [
    secp192k1, secp192r1, secp160k1, secp160r1, secp160r2, brainpoolP160r1,
    brainpoolP160t1, brainpoolP192r1, brainpoolP192t1
]
other_curves = [sm2group]
all_prime_order_curves = predefined_curves + weak_curves + other_curves
all_curves = all_prime_order_curves + ec_binary.binary_curves

JWK_CURVES = ["P-256", "P-384", "P-521", "secp256k1"]
jwk_curves = [curveP256, curveP384, curveP521, secp256k1]
assert set(JWK_CURVES) == set(c.jwk_name for c in jwk_curves)

def named_curve(name: str):
  name_lower = name.lower()
  for c in all_prime_order_curves + ec_binary.binary_curves:
    for n in (c.name, c.jwk_name, c.ansi_name):
      if n and n.lower() == name_lower:
        return c
  raise Exception(name + " is not a know elliptic curve")

isomorphisms = [
    brainpoolP160Isomorphism, brainpoolP192Isomorphism,
    brainpoolP224Isomorphism, brainpoolP256Isomorphism,
    brainpoolP384Isomorphism, brainpoolP512Isomorphism
]

def isomorphic_points(group, P):
  for iso in isomorphisms:
    if iso.A == group:
      yield iso.B, iso.fromAtoB(P)
    if iso.B == group:
      yield iso.A, iso.fromBtoA(P)
