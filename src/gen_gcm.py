# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import gcm
import aes_gcm
import aria_gcm
import camellia_gcm
import sm4_gcm
import seed_gcm
import aes_ktv
import aria_ktv
import sm4_ktv
import seed_ktv
import aead_test_vector
import producer
import util
import flag


# TODO:
#   Add flags more consistently. E.g., flags should be added to KTVs too.

# CVEs:
#   CVE-2021-3744: memory leak, no details
#   CVE-2021-32791: incorrect use (static IV)
#   CVE-2020-8912: implementation allows CTR and GCM with same key.
#   CVE-2020-8897: AWS uses GCM in situation where committing is required.?
#   CVE-2020-6018: memory overflow for long messages during decryption
#   CVE-2020-8912: python-cryptography did not check the tag size.
#   CVE-2018-1000539: Improper verification (i.e. 1 byte tag is accepted)
#   CVE-2017-7822: zero length IV
#   CVE-2017-18330 buffer overflow with long IV.
#   CVE-2016-7798: nonce reuse.
#   CVE-2016-2427: 12 byte tag by default (so what?)
#   CVE-2016-10213: uses random IV (can determine the size)
#   CVE-2016-10212: nonce reuse
#   CVE-2015-4550: fails to verify tag (to what extend?)


ALGORITHMS = ["AES-GCM", "ARIA-GCM", "CAMELLIA-GCM", "SM4-GCM", "SEED-GCM"]
class GcmTestGenerator(aead_test_vector.AeadTestGenerator):
  def __init__(self, algorithm, args):
    super().__init__(algorithm, args)
    if algorithm == "AES-GCM":
      self.aead = aes_gcm.AesGcm
      self.ktv = aes_ktv.AES_GCM_KTV
    elif algorithm == "ARIA-GCM":
      self.aead = aria_gcm.AriaGcm
      self.ktv = aria_ktv.ARIA_GCM_KTV
    elif algorithm == "CAMELLIA-GCM":
      self.aead = camellia_gcm.CamelliaGcm
      self.ktv = []
    elif algorithm == "SM4-GCM":
      self.aead = sm4_gcm.Sm4Gcm
      self.ktv = sm4_ktv.SM4_GCM_KTV
    elif algorithm == "SEED-GCM":
      self.aead = seed_gcm.SeedGcm
      self.ktv = seed_ktv.SEED_GCM_KTV
    else:
      raise ValueError("Unknown algorithm:" + algorithm)

    # Get the key sizes.
    supported_key_sizes = self.aead.block_cipher.key_sizes_in_bytes
    if getattr(args, "key_sizes", None):
      self.keysizes = [x // 8 for x in args.key_sizes]
      for sz in self.keysizes:
        if sz not in supported_key_sizes:
          raise ValueError("Unsupported key size")
    else:
      self.keysizes = supported_key_sizes

  def generate_iv(self, key: bytes, msg: bytes):
    """Generates test vectors with special case IVs.

    GCM wraps the counter at 2^32 boundaries. This function
    generates test vectors to check for bugs. Such test vectors
    can be generated by selecting j0, then reverse the GHASH to get
    a corresponding 16 byte IV.

    Args:
      key: the GCM key.
      msg: the message to encrypt
    """
    wrap = flag.Flag(
        label="CounterWrap",
        bug_type=flag.BugType.AUTH_BYPASS,
        description="The counter for GCM is reduced modulo 2**32. "
        "This test vector contains values such that the GCM counter wraps "
        "around.",
        effect="When the size of the IV is not 12 bytes then detecting "
        "incorrect encryptions leaks the information that the GHASH of the IV "
        "was close to a multiple of 2**32. Combining this information from "
        "multiple incorrect encryptions allows to recover the authentication "
        "key.")
    A = self.aead(key)
    for j0 in (
        "000102030405060708090a0b0c0d0e0f",
        "00000000000000000000000000000000",
        "ffffffffffffffffffffffffffffffff",
        "fffffffffffffffffffffffffffffffe",
        "fffffffffffffffffffffffffffffffd",
        "000102030405060708090a0bffffffff",
        "000102030405060708090a0bfffffffe",
        "000102030405060708090a0bfffffffd",
        "000102030405060708090a0b7fffffff",
        "000102030405060708090a0b7ffffffe",
        "000102030405060708090a0bffff7fff",
        "000102030405060708090a0bffff7ffe",
    ):
      iv = A.getIvForCounter(bytes.fromhex(j0))
      aad = b""
      self.add_vector(key, iv, aad, msg, comment="J0:" + j0, flags=[wrap])

  def generate_pt(self, key: bytes, iv: bytes, tag: bytes, comment: str,
                  flags: list[flag.Flag]):
    """Generate test vectors for fixed values of key, iv and tag.

    Args:
      key: the GCM key to use.
      iv: the IV to use
      tag: the requested tag.
      comment: a comment describing the test vector
      flags: flags for the test vector
    """
    aad = b""
    A = self.aead(key)
    pt, ct = A.get_pt_ct_for_iv_and_tag(iv, tag)
    assert (ct, tag) == A.encrypt(iv, aad, pt)
    self.add_vector(key, iv, aad, pt, ct, tag, comment=comment, flags=flags)

  def generate_special_case(self):
    """Generates test vectors with special cases for iv and tag."""
    special_case = flag.Flag(
        label="SpecialCase",
        bug_type=flag.BugType.EDGE_CASE,
        description="The test vector contains special cases for "
        "iv and tag.")
    for keysize in self.keysizes:
      k = bytes([17 * i % 256 for i in range(keysize)])
      self.generate_iv(k, bytes(40))
      z = bytes([0])
      ff = bytes([0xff])
      for iv, tag, comment in [(12 * z, 16 * ff, "special case"),
                               (12 * ff, 16 * z, "special case"),
                               (16 * z, 16 * z, "special case"),
                               (16 * ff, 16 * ff, "special case")]:
        self.generate_pt(k, iv, tag, comment, flags=[special_case])

  def generate_ktv(self):
    flag_ktv = flag.Flag(
        label="Ktv",
        bug_type=flag.BugType.BASIC,
        description="Known test vector.")

    for t in self.ktv:
      msg, key, nonce, aad, ct, tag = [
          bytes.fromhex(t[n]) for n in ("msg", "key", "iv", "aad", "ct", "tag")
      ]
      if len(key) in self.keysizes:
        self.add_vector(key, nonce, aad, msg, flags=[flag_ktv])

  def generate_prand(self):
    pseudorandom = flag.Flag(
        label="Pseudorandom",
        bug_type=flag.BugType.FUNCTIONALITY,
        description="The test vector contains pseudorandomly generated inputs. "
        "The goal of the test vector is to check the correctness of the "
        "implementation for various sizes of the input parameters. "
        "Some libraries do not support all the parameter sizes. "
        "In particular the size of the IV is often restricted.")

    # cnt, keysize, ivsize, aadsize, msgsize
    # different message sizes with 12 byte IV
    self.generate_pseudorandom(
        1,
        self.keysizes, [12], [0], [0, 1, 8, 15, 16, 17, 24],
        flags=[pseudorandom])
    # different message sizes with 16 byte IV
    self.generate_pseudorandom(
        1, self.keysizes, [16], [0], [0, 1, 15, 16, 32], flags=[pseudorandom])
    # different aad sizes
    self.generate_pseudorandom(
        1, self.keysizes, [12], [1, 8, 16, 24], [20], flags=[pseudorandom])
    # longer message size
    self.generate_pseudorandom(
        1,
        self.keysizes, [12], [0],
        [63, 64, 65, 127, 128, 129, 255, 256, 257, 511, 512, 513],
        flags=[pseudorandom])
    # longer aad size
    self.generate_pseudorandom(
        1,
        self.keysizes, [12],
        [63, 64, 65, 127, 128, 129, 255, 256, 257, 511, 512, 513], [20],
        flags=[pseudorandom])

  def generate_longiv(self):
    # GCM allows arbitrary IV sizes.
    # IV"s with a size != 12 are first passed through Ghash.
    # uncommon ivsizes.
    longiv = flag.Flag(
        label="LongIv",
        bug_type=flag.BugType.FUNCTIONALITY,
        description="GCM allows long IVs. Such IVs are compressed using GHASH "
        "to generate the CTR values. Some implementations restrict the range "
        "of the IV sizes.",
        effect="If IV sizes other than 12 bytes are supported then the "
        "correctness of the implementation is critical. An incorrect "
        "implementation of long IVs can (and probably does) leak "
        "the authentication key.")
    self.generate_pseudorandom(
        1,
        self.keysizes, [15, 20], [0], [12],
        "unusual IV size",
        flags=[longiv])
    self.generate_pseudorandom(
        1,
        self.keysizes, [32, 64, 128, 257], [0], [12],
        "long IV size",
        "valid",
        flags=[longiv])

  def generate_zeroiv(self):
    zeroiv = flag.Flag(
        label="ZeroLengthIv",
        bug_type=flag.BugType.AUTH_BYPASS,
        description="GCM does not allow an IV of length 0. "
        "Encrypting with an IV of length 0 leaks the authentication key. "
        "Hence using an IV of length 0 is insecure even if the key itself is "
        "only used for a single encryption.",
        cves=["CVE-2017-7822"])
    self.generate_pseudorandom(
        1,
        self.keysizes, [0], [0], [0, 16],
        "0 size IV is not valid",
        "invalid",
        flags=[zeroiv])

  def generate_smalliv(self):
    smalliv = flag.Flag(
        label="SmallIv",
        bug_type=flag.BugType.WEAK_PARAMS,
        description="GCM leaks the authentication key if the same IV is used "
        "twice. Hence short IV sizes are typically discouraged or "
        "generated with a special construction such as the one "
        "described in Section 8.2 of NIST SP 800-38d. "
        "Some libraries may reject small IV sizes.")
    self.generate_pseudorandom(
        1,
        self.keysizes, [1, 2, 4, 6, 8, 10], [0], [0, 16],
        "small IV sizes",
        "valid",
        flags=[smalliv])

  def generate_modified(self):
    """Generates test vectors with modified tags."""
    for keysize in self.keysizes:
      key = bytes(range(keysize))
      nonce = bytes(range(80, 92))
      aad = bytes()
      message = bytes(range(32, 48))
      self.generate_modified_tag(key, nonce, aad, message)

  def generate_all(self):
    self.generate_ktv()
    self.generate_special_case()
    self.generate_prand()
    self.generate_longiv()
    self.generate_smalliv()
    self.generate_zeroiv()
    self.generate_modified()

class GcmProducer(producer.Producer):

  def parser(self):
    res = self.default_parser()
    res.add_argument(
        "--key_sizes",
        type=int,
        nargs="+",
        choices=[128, 192, 256],
        help="a list of key sizes in bits")
    res.add_argument(
        "--algorithm",
        type=str,
        choices=ALGORITHMS,
        default="AES-GCM",
        help="the name of the algorithm")
    return res

  def generate_test_vectors(self, namespace):
    algorithm = getattr(namespace, "algorithm")
    tv = GcmTestGenerator(algorithm, namespace)
    tv.generate_all()
    return tv.test


# DEPRECATED: Use Producer.produce() instead
def main(namespace):
  GcmProducer().produce(namespace)


if __name__ == "__main__":
  GcmProducer().produce_with_args()
